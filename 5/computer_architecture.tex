
\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}

\usepackage{amsmath}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}
\renewcommand{\arraystretch}{1.3}         % because math expressions

\title{Компютърни архитектури. Формати на данните. Вътрешна структура на централен процесор – блокове и конвейерна обработка, инструкции.}
\author{v0.1}
\date{31 май 2021}

\begin{document}

\maketitle

\tableofcontents

\begin{flushleft}

\section{Обща структура на компютрите и концептуално изпълнение на инструкциите,
запомнена програма.}

\section{Формати на данните}
\subsection{Цели двоични числа}
Целите числа се представят в двоична бройна система в групи от 8, 16, 32 или 64 бита. Съответно групата от 8 бита се нарича \textbf{байт},
а една от останалите - \textbf{машинна дума}, в зависимост от разрядността на процесора. Целите числа могат да бъдат със и без знак.
Отрицателните числа със знак се представят по схемата \textbf{допълнение към двойката} - най-старшият бит се ползва за знак (0 - положително число, 1 - отрицателно).
Нека е дадено двоично числа със знак с $N$ бита. Неговата стойност е
\[ \overline{a_{N-1} a_{N-2} \dots a_0}_{2c} = \begin{cases}
    \overline{a_{N-2} a_{N-3} \dots a_0}_2, & a_{N-1} = 0 \\
    -2^{N-1} + \overline{a_{N-2} a_{N-3} \dots a_0}_2, & a_{N-1} = 1
\end{cases}
\]

Минималните и максималните стойности за $N$-битово число с това представяне са съответно $-2^{N-1}$ и $2^{N-1} - 1$ - не са симетрични. 
Нулата има единствено представяне - $\overline{00\dots0}_{2c}$, което съвпада с нейното представяне за неотрицателни числа.
Част от причините тази схема да се ползва, е че няма нужда от различен хардуер за събиране и изваждане - възползваме се от превъртането (overflow).

\textit{Пример: } $-1 + 3 = \overline{1111}_{2c} + \overline{0011}_{2c} = \overline{0010}_{2c} = 2$. 

Хардуера за умножение и деление обаче не може да игнорира старшия бит за знак - и това се отразява във съотвените инструкции.

\subsection{Двоично-десетични числа}
Архитектурата \textbf{x86} поддържа \textbf{двоични-десетични числа (binary coded decimal)}, които използват десетична бройна система като
записват всяка десетична цифра с 4 бита. Съществуват два формата:
\begin{itemize}
    \item \textbf{пакетиран}, при който се съхраняват две десетични цифри в байт, и
    \item \textbf{непакетиран}, при който се съхранява по една десетична цифра в байт
\end{itemize}
Както се вижда, този формат е по-неефикасен откъм място за съхранение. По неефикасен е и за пресмятане, понеже всички операции са 
дефинирани над напрактика низове, вместо машинни думи. Предимство на формата е че няма загуби при конверсия на десетични рационални числа
(например $0.3$ е безкрайна двоична дроб).

\subsection{Двоично числа с плаваща запетая}
\subsection{Символни данни и кодови таблици}

\section{Вътрешна структура на централен процесор}
\subsection{Регистри}
\subsection{Аритметико-логическо устройство}
\subsection{Регистър на състоянието и флагове}
\subsection{Блок за управление}

\section{Инструкции на централен процесор}
\subsection{Префикси}
\subsection{Код на операцията}
\subsection{Местоположение на операндите}
\subsection{Модели на адресация на операндите}
\subsection{Аритметико-логически инструкции}
\subsection{Низови инструкции}
\subsection{Безусловни и условни преходи}
\subsection{Управление на програмата}


\end{flushleft}
\end{document}
