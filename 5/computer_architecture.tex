
\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}
\usepackage{indentfirst}

\usepackage{amsmath}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}
\renewcommand{\arraystretch}{1.3}         % because math expressions

\title{Компютърни архитектури. Формати на данните. Вътрешна структура на централен процесор – блокове и конвейерна обработка, инструкции.}
\author{v0.1}
\date{31 май 2021}

\begin{document}

\maketitle

\tableofcontents

\section{Обща структура на компютрите и концептуално изпълнение на инструкциите,
запомнена програма.}

\section{Формати на данните}

\subsection{Цели двоични числа}
\label{subsection:integers}
Целите числа се представят в двоична бройна система в групи от 8, 16, 32 или 64 бита. Съответно групата от 8 бита се нарича \textbf{байт},
а една от останалите - \textbf{машинна дума}, в зависимост от разрядността на процесора. Целите числа могат да бъдат със и без знак.
Отрицателните числа със знак се представят по схемата \textbf{допълнение към двойката} - най-старшият бит се ползва за знак (0 - положително число, 1 - отрицателно).
Нека е дадено двоично числа със знак с $N$ бита. Неговата стойност е
\[ \overline{a_{N-1} a_{N-2} \dots a_0}_{2c} = \begin{cases}
    \overline{a_{N-2} a_{N-3} \dots a_0}_2, & a_{N-1} = 0 \\
    -2^{N-1} + \overline{a_{N-2} a_{N-3} \dots a_0}_2, & a_{N-1} = 1
\end{cases}
\]

Минималните и максималните стойности за $N$-битово число с това представяне са съответно $-2^{N-1}$ и $2^{N-1} - 1$ - не са симетрични. 
Нулата има единствено представяне - $\overline{00\dots0}_{2c}$, което съвпада с нейното представяне за неотрицателни числа.
Част от причините тази схема да се ползва, е че няма нужда от различен хардуер за събиране и изваждане - възползваме се от превъртането (overflow).

\textit{Пример: } $-1 + 3 = \overline{1111}_{2c} + \overline{0011}_{2c} = \overline{0010}_{2c} = 2$. 

Хардуера за умножение и деление обаче не може да игнорира старшия бит за знак - и това се отразява във съотвените инструкции.

\subsection{Двоично-десетични числа}
Архитектурата \textbf{x86} поддържа \textbf{двоични-десетични числа (binary coded decimal)}, които използват десетична бройна система като
записват всяка десетична цифра с 4 бита. Съществуват два формата:
\begin{itemize}
    \item \textbf{пакетиран}, при който се съхраняват две десетични цифри в байт, и
    \item \textbf{непакетиран}, при който се съхранява по една десетична цифра в байт
\end{itemize}
Както се вижда, този формат е по-неефикасен откъм място за съхранение. По неефикасен е и за пресмятане, понеже всички операции са 
дефинирани над напрактика низове, вместо машинни думи. Предимство на формата е че няма загуби при конверсия на десетични рационални числа
(например $0.3$ е безкрайна двоична дроб).

\subsection{Двоично числа с плаваща запетая}
Рационалните числа се представят чрез \textbf{двоични числа с плаваща запетая (floating point)}.
Ирационални числа (напр. $\sqrt{2}, \pi$) не могат да се представят с крайна памет, така че се апроксимират с рационални.
Те са разделени на три части: знак (1 бит), мантиса и експонента. Стойността на такова число е \textbf{sgn} $ \times $ $ m \times 2^e$.
Процесорите най-често имплементират стандарт \textbf{IEEE 754}, и по-точно два формата от него:
\begin{itemize}
    \item \textbf{binary32}, наричан още \textbf{single precision}. Ползва 24 бита за мантиса и 8 за експонента. В езиците за програмиране най-често се нарича \textbf{float}.
    \item \textbf{binary64}, наричан още \textbf{double precision}. Ползва 53 бита за мантиса и 11 за експонента. В езиците за програмиране най-често се нарича \textbf{double}.
\end{itemize}

\textbf{TODO}: Повече обяснения как работи

\subsection{Символни данни и кодови таблици}
Символните низове се представят чрез поредица от числа - най-често 8 битови, но понякога 16 или 32-битови. 
За интерпретация (и печатане) на символите се използват \textbf{кодови таблици}, като най-често срещаните са:
\begin{itemize}
    \item \textbf{ASCII} - използва фиксирана големина на символ 1 байт. Стойностите от 0 до 127 са винаги едни и същи, докато
    $[128,255]$ са различни в зависимост от настройката за регион на компютъра. Тази различност е най-честата причина за нечетими
    текстови файлове и съобщения - някои стари програми и/или ОС използват регионалната ASCII таблица.
    \item \textbf{UTF-8} - използва кодиране с променлива дължина на символите. Съвпада с ASCII до 127 включително.
    \item \textbf{UTF-16} и \textbf{UTF-32} - използва същите кодове като \textbf{UTF-8}, но използва фиксирана дължина 2 или 4 байта
\end{itemize}

\textbf{TODO}: Повече инфо

\section{Вътрешна структура на централен процесор}
\subsection{Регистри}
Регистрите представляват изключително бърза памет (всъщност най-бързата в системата) с много малък размер. Обикновено големината им е от 8 до 512 бита (напр. при AVX512),
като повечето са с големината на машинната дума (16, 32, 64) или някое нейно кратно число. Можем да ги разделим на няколко вида:
\begin{itemize}
    \item С общо предназначение
    \item За числа с плаваща запетая
    \item SIMD регистри
    \item Сегментни регистри
    \item Флагови и контролни регистри
    \item Указател на следващата инструкция
\end{itemize}

Общият брой регистри е от порядъка на 128. Ще разгледаме някои регистри на \textbf{x86} архитектурата по-подробно.

\subsubsection{Регистри с общо предназначение}
Това са регистрите \textit{AX, BX, CX, DX, BP, SI, DI, SP} - 16 битови. При 32-битовия вариант се добавя представка \textit{E-} (напр. \textit{EAX}),
а за 64-битов вариант се добавя \textit{R-} (напр. \textit{RAX}). Разбира се, 32 и 64-битовите варианти се поддържат единствено на 32 и 64 битова архитектура.

По-големите регистри съдържат по-малките - например за \textit{A} регистъра \textit{AX} образува долните 16 бита на \textit{EAX} и \textit{RAX},
a \textit{EAX} съдържа долните 32 бита на \textit{RAX}. 
Регистрите \textit{A,B,C,D} се делят на още две части - \textit{H} и \textit{L} (напр. \textit{AH, AL}), които са 8 битови. 
При \textbf{x86\_64} са добавени още 8 регистъра - \textit{R8..R15}, като долните 32 бита са достъпни като \textit{R8D..R15D}.

Ще опишем накратко употребата на тези регистри:
\begin{itemize}
    \item \textit{[RE]?AX} - акумулатор, предназначен за операнди и резултати.
    \item \textit{[RE]?BX} - \textbf{base} регистър за адреси в паметта.
    \item \textit{[RE]?CX} - \textbf{counter} (брояч). Използва се за цикли.
    \item \textit{[RE]?DX} - за данни. Ползва се за входно-изходни устройства и някои аритметични операции.
    \item \textit{[RE]?SP} - стеков регистър. Сочи към първата свободна памет на стека.
    \item \textit{[RE]?BP} - базов стеков регистър. Запазва състоянието (размера на стека) при влизане във функция.
    \item \textit{[RE]?SI} - \textbf{source index}. Използва се за указател към входнни данни, понякога заедно със сегментния \textit{DS}.
    \item \textit{[RE]?DI} - \textbf{destination index}. Използва се за указател към изходните данни, понякога заедно със сегментния \textit{ES}.
\end{itemize}

Предназначението често е условно - повечето регистри могат да се ползват за повечето операции.

\subsubsection{Регистри за числа с плаваща запетая}
Това са \textit{ST0 ... ST7}, които са организирани като стек. Всеки е с големина 80 бита (стандарта за числа с плаваща запетая позволява
междинните резултати да са с по-голяма прецизност).

\subsubsection{SIMD регистри}
Това са регистри, които се появяват по-късно в еволюцията на \textbf{x86} архитектурата. Съкращението \textbf{SIMD} означава \textbf{single instruction, multiple data}, т.е. са предназначени да съдържат няколко типа с по-малък размер. Първоначално се добавят MMX регистрите, които всъщност се припкриват със 
\textit{ST0 ... ST7} и са със ширина 64 бита. След това се добавят XMM, YMM и ZMM регистри със ширина 128, 256 и 512 бита.

\subsubsection{Сегментни регистри}
Те са 6 на брой и всеки от тях е 16 битов, независимо от това колко битов е процесора (не стават по-големи, за разлика от гореописаните).
Използват се при включена сегментация на паметта. Всеки регистър съдържа селектор за сегмент, който е или указател към началото, или индекс
в таблица със сегменти.
\begin{itemize}
    \item \textit{CS} - \textbf{code segment}. Съдържа селектора за сегмента на програмата (изпълнимия код).
    \item \textit{DS} - \textbf{data segment}. Селектор за данните.
    \item \textit{ES} - \textbf{extra segment}. Допълнителен селектор за данни - често се използва за записване на резултат.
    \item \textit{SS} - \textbf{stack segment}. Съдържа селектора за стека.
    \item \textit{FS, GS} - допълнителни селектори без зададено предназначение.
\end{itemize}

При адресиране в паметта сегментният регистър може да се укаже изрично, но при много инструкции има "стандарни" регистри, които се ползват.
При 64-битов режим на работа всички сегменти регистри, освен \textit{FS} и \textit{GS}, се нулират.

\subsubsection{Указател на следващата инструкция}
Това е регистърът \textit{IP/EIP/RIP} - \textbf{instruction pointer}. Популярно наименование на регистър с тази функция е също 
\textit{PC} - \textbf{Program Counter}. Функцията му е просто: съдържа адреса на следващата инструкция, която трябва да се изпълни.
При \textbf{x86} архитектурата този регистър не може да се пише или чете директно - това се случва чрез инструкции за преходи.

Регистърът за флагове, както и контролните регистри, разглеждаме в \ref{section:flags}.

\subsection{Аритметико-логическо устройство}

\subsection{Регистър на състоянието и флагове}
\label{section:flags}
Флаговият регистър се казва \textit{[RE]?FLAGS}. "Флагове" наричаме индивидуални негови битове, като биват три вида: статус, контролни и системни.
Статусните се попълват автоматично като резултати на аритметико-логически операции и са само за четене:
\begin{itemize}
    \item \textbf{Zero}
    \item \textbf{Overflow}
    \item \textbf{Carry}
    \item \textbf{Auxillary carry}
\end{itemize}

Контролните флагове могат да бъдат записвани от програмата, за да (изненада) контролират поведението на процесора.
\begin{itemize}
    \item \textbf{Interrupt enable flag} - включва и изключва обработването на външните прекъсвания.
    \item \textbf{Direction flag} - указва дали низовете да се обработват от ниски към високи адреси или обратно.
\end{itemize}

От системните флагове може да се извлече информация за текущата конфигурация на процесора.

Контролните регистри са \textit{CR0,\dots,CR7}, като директно използваеми са \textit{CR0, CR2, CR3} и \textit{CR4}. Използват се за:
\begin{itemize}
    \item Задаване на режим на процесора (реален, привилигирован, виртуално 8086)
    \item Странициране - включване + адреси на таблици + адрес, който е генерирал \textbf{page fault}
    \item Прекъсвания
    \item Получаване на информация за конфигурацията
    \item и други
\end{itemize}

Освен тях съществуват и други регистри, които съдържат адреси на разнообразни таблици.

\subsection{Блок за управление}

\section{Инструкции на централен процесор}
Инструкциите на \textbf{x86} имат следните полета (изброени в реда на появяване):
\begin{enumerate}
    \item Префикси
    \item REX префикс
    \item Код на операцията
    \item ModR/M байт
    \item SIB байт
    \item Отместване
    \item \textbf{Immediate} операнд
\end{enumerate}

\subsection{Префикси}
Това са незадължителни полета. Първите префикси се делят на четири групи:
\begin{enumerate}
    \item \label{prefix:group1} \textbf{LOCK}, която служи за ексклузивно ползване на споделена памет, и префикси за повторение, които се ползват за низови и \textbf{I/O} инструкции
    \item Подсказки за разклонения
    \item Промяна на размера на операнда
    \item Промяна на размера на адресите 
\end{enumerate}

REX префикса се използва в 64 битов режим на работа. Необходим е за използване на допълнителните регистри, или за указване на 64-битови данни/адреси.

\subsection{Код на операцията}
Поредица от байтове, които указват какво трябва да свърши процесора. При \textbf{x86} това поле може да е с променлива дължина (1-3 байта), докато 
при други архитектури може да е фиксирано.

\subsection{Местоположение на операндите}
Операндите на всяка инструкция могат да са \textbf{immediate} (записани директно в инструкцията, т.е. константи), да се намират в регистри 
или в паметта. При някои инструкции някои операнди са зададени директно в кода на операцията.

\subsection{Модели на адресация на операндите}
Има няколко начина инструкция да си намери операндите:
\begin{enumerate}
    \item регистърна адресация - в инструкцията е зададен код на регистър, чиято стойност трябва да се ползва/запише
    \item директна - адреса в паметта е подаден като отместване
    \item индиректна - адреса в паметта се получава от няколко регистъра, чиито кодове са записани в инструкцията
\end{enumerate}

Всички архитектури поддържат двойките на адресация "регистър-памет" за зареждане и записване и "регистър-регистър" за АЛ операции. 
\textbf{CISC} архитектурите, каквато е \textbf{x86}, поддържат и аритметико-логически операции "регистър-памет".

При \textbf{x86} индиректната адресация винаги работи по формулата $ base + index . 2^{scale} + displacement $,
където \textbf{scale}, \textbf{index} и \textbf{base} са регистри, които се задават с комбинация от 
\textbf{ModR/M}, \textbf{SIB} (чието съкращение идва от точно тези 3 думи) и \textbf{REX}. Всяка част от формулата
може да бъде пропусната - напр. не е необходимо два регистъра да се задават на 0, ако ползваме директно адреса от 1 регистър.

\subsection{Аритметико-логически инструкции}
\subsubsection{С цели числа}
Това са инструкциите за увеличаване/намаляване с 1 (\textbf{INC / DEC}), събиране и изваждане (\textbf{ADD / SUB}),
умножение и деление на числа без знак (\textbf{MUL / DIV}), както и на числа със знак (\textbf{IMUL / IDIV}).
Причината само умножението и делението да са "разделени" обсъдихме в \ref{subsection:integers}.
Всички тези операции имат страничен ефект - променят флагове във флаговия регистър.

Към тази група операции причисляваме и побитовите операции - \textbf{AND, OR, XOR, NOT}, които също променят флаговете.
Има и допълнителен вариант на \textbf{AND} - \textbf{TEST}, който единствено променя флаговете, но не и операндите.

Като финална инструкция от групата можем да смятаме \textbf{CMP}, която, както й подсказва името, извършва сравнения.
Резултата от тях отново се отразява във флаговия регистър.

\subsubsection{С числа с плаваща запетая}
Числата с плаваща запетая имат аналог на всички гореописани инструкции, плюс допълнителни:
\begin{enumerate}
    \item конверсия към и от цели числа
    \item модул (абсолютна стойност)
    \item аритметични операции между числа с плаваща запетая и цели числа
    \item тригонометрични операции
\end{enumerate}

\subsection{Низови инструкции}
При \textbf{x86} са добавени допълнителни инструкции с цел ускоряване на работата със символни низове.
Тези инструкции могат да се ползват вместо конвенционални цикли, които заемат няколко други инструкции.
Общо има 5 низови инструкции, като размера на символа може да е 8, 16 или 32 битов.
\begin{enumerate}
    \item \textbf{MOVS} - копира символ от един низ в друг
    \item \textbf{LODS} - зарежда символ от низ в съответната част от \textbf{A} регистъра.
    \item \textbf{STOS} - записва символа от съответната част от \textbf{A} регистъра в низ.
    \item \textbf{CMPS} - сравнява два символа от два низа.
    \item \textbf{SCAS} - сравнява символ от низ със съдържанието на съответната част от \textbf{X} регистъра.
\end{enumerate}

Тези инструкции могат да се комбинират с префикси за повторение - група \ref{prefix:group1}. 
В зависимост от представката, инструкцията се повтаря докато \textbf{ECX} стане 0 или се стигне
до равенство/неравенство.

\subsection{Безусловни и условни преходи}
\subsection{Управление на програмата}

\end{document}
