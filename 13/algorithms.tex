
\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}
\usepackage{indentfirst}
\usepackage{array}
\usepackage{listings}

\usepackage{amsmath}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}

\title{Структури от данни и алгоритми. Анализ на алгоритми. Абстрактни
типове от данни. Стек, опашка, списък, дърво. Сортиране.}

\author{v0.1}
\date{24 юни 2021}

\begin{document}

\maketitle

\tableofcontents

\section{Анализ на алгоритми}
\subsection{Въведение / необходимост}
TODO

\subsection{Асимптотична нотация на сложността}
\subsubsection{Дефиниция}
Нека $f, g : \mathbb{N} \rightarrow \mathbb{R}$. Казваме, че $f$ расте по-бавно от $g$ (или че $g$ мажорира $f$) и означаваме $f \prec g$, ако 
съществува $c \in \mathbb{R}$ и $n_0 \in \mathbb{N}$, за които е изпълнено $N > n_0 \Rightarrow f(N) < c.g(N)$.
Чрез $f \preceq g$ означаваме нестрогата форма на неравенството - $g$ расте поне толкова бързо, колкото $f$.

Нека $f : \mathbb{N} \rightarrow \mathbb{R}$. Дефинираме следните множества чрез релациите $\prec$ и $\preceq$:
\begin{itemize}
    \item $O(f) = \{g \hspace{2mm} | \hspace{2mm} g \preceq f\}$
    \item $o(f) = \{g \hspace{2mm} | \hspace{2mm} g \prec f\}$
    \item $\Omega(f) = \{g \hspace{2mm} | \hspace{2mm} f \preceq g\}$
    \item $\omega(f) = \{g \hspace{2mm} | \hspace{2mm} f \prec g\}$
    \item $\Theta(f) = \{g \hspace{2mm} | \hspace{2mm} f \preceq g \preceq f\}$
\end{itemize}

\subsubsection{Наредба на стандартните функции}
\noindent\[ C \prec \log \log N \prec \log N \prec \sqrt{N} \prec N \prec N^2 \prec N^3 \prec 2^N \prec 3^N \prec N! \prec N^N \]

\subsubsection{Свойства и примери}
Ако $f \preceq g$ и $h(n) = f(n) + g(n)$, то $h(n) \in \Theta(f)$.
Следвателно ни интересува само най-големия член на дадена формула, например
$N^2 + \log N + 5 \in O(N^2)$.

\subsection{Основни рекурентни формули}
\subsubsection{Дефиниция}
Нека с $T(N)$ обозначим времето за работа на алгоритъм при размер на входа $N$.
Ако можем да изразим $T(N)$ чрез формула, съдържаща $T$, то изразът наричаме \textbf{рекуретна формула}.
Такива изрази възникват често, когато алгоритми използват рекурсия.

Времето $T(N)$ можем да разглеждаме в най-лошия, средния и най-добрия случай (подредени по важност).
Освен време, по същия начин можем да разглеждаме и паметта, която алгоритъмът използва - нека я обозначим $M(N)$.
Очевидно $M(N) \preceq T(N)$.

\subsubsection{Примери}

\begin{center}
\begin{tabular}{|c|c|m{80mm}|}
    \hline
    Формула & Сложност & Примерен алгоритъм \\ 
    \hline
    $T(N) = T(N - 1) + N$ & $\Theta(N^2)$ & Наивна сортировка \\  
    \hline
    $T(N) = T\left(\dfrac{N}{2}\right) + 1$ & $\Theta(\log N)$ & Двоично търсене \\  
    \hline    
    $T(N) = T\left(\dfrac{N}{2}\right) + N$ & $\Theta(N)$ & Среден случай на търсене на медиана с \textbf{quick select} \\  
    \hline   
    $T(N) = 2T\left(\dfrac{N}{2}\right) + N$ & $\Theta(N \log N)$ & Бърза сортировка \\  
    \hline
    $T(N) = 2T\left(\dfrac{N}{2}\right) + 1$ & $\Theta(N)$ & Търсене на минимален елемент по схемата "разделяй и владей" \\  
    \hline     
\end{tabular}
\end{center}

\subsection{Примери за анализ на алгоритми}

\subsubsection{Двоично търсене}
Ще докажем, че сложността на двоичното търсене е $O(\log N)$.
Нека обозначим с $l_k$ и $r_k$ стойностите на променливите $left$ и $right$ на $k$-тата итерация на цикъла (нека първата итерация е $k = 0$).
Тогава размерът на масива, в който търсим, на всяка итерация е $N_k = r_k - l_k + 1$. За индекса на сравнение $m_k$ получваме
$m_k = \Big\lfloor\dfrac{l_k + r_k}{2}\Big\rfloor$ Интересува ни какво е $N_{k + 1}$, като имаме два случая:
\begin{itemize}
    \item $l_{k+1} = l_k, r_{k+1} = m_k - 1$. Тогава $N_{k+1} = \Big\lfloor\dfrac{l_k + r_k}{2}\Big\rfloor - 1 - l_k + 1 \leq \dfrac{l_k + r_k}{2} - l_k = \dfrac{N_k - 1}{2}$.
    Съответно $N_{k+1} \leq \Bigg\lfloor \dfrac{N_k}{2} \Bigg\rfloor$.
    \item $l_{k+1} = m_k + 1, r_{k+1} = r_k \Rightarrow N_{k+1} = r_k - \Big\lfloor\dfrac{l_k + r_k}{2}\Big\rfloor - 1 + 1 < \dfrac{r_k - l_k}{2} + 1 = \dfrac{N_k - 1}{2} + 1$. 
    $\dfrac{N_k - 1}{2} + 1 = \dfrac{N_k + 1}{2} = \Bigg\lceil \dfrac{N_k}{2} \Bigg\rceil$.
    Съответно получваме $N_{k+1} < \Bigg\lceil \dfrac{N_k}{2} \Bigg\rceil \Leftrightarrow N_{k+1} \leq \Bigg\lceil \dfrac{N_k}{2} \Bigg\rceil - 1 \Leftrightarrow $
    $N_{k+1} \leq \Bigg\lfloor \dfrac{N_k}{2} \Bigg\rfloor$
\end{itemize}

И двата случая получихме $N_{k+1} \leq \Bigg\lfloor \dfrac{N_k}{2} \Bigg\rfloor$.
Можем да приложим неравенството няколко пъти, както и да почнем от $N_0 = N$. 
Тогава получваме $N_k \leq \Bigg\lfloor \dfrac{N}{2^k} \Bigg\rfloor$. Алгоритъмът спира при $N_k < 1$,
следователно може да има най-много $\log_2 N$ стъпки $\Rightarrow O(\log N)$.

Алтернативно, можем да съставим рекурентна формула за времето в най-лошия случай - $T(n) = T\left(\frac{N}{2}\right) + 1$.
Вече споменахме, че за тази формула $T(n) \in \theta(\log N)$. 

Ако искаме да докажем и коректността на алгоритъма, то трябва да намерим и докажем инвариантата на цикъла.
В този случай това е следното твърдение: \textit{Елементът със стойност $target$ \textbf{не} се намира в подмасивите с индекси $0 \dots l_k - 1$ и $r_k + 1 \dots size - 1$}.
Доказването на инвариантите на цикъл обаче е извън обхвата на темата, така че ще го пропуснем.

\begin{lstlisting}[language=C++, caption=Двоично търсене]
int binary_search(const int * arr, const int size, const int target)
{
    int left = 0;
    int right = size - 1;

    while (left <= right)
    {
        const int m = (left + right) / 2;
        if (arr[m] == target) return m;
        if (arr[m] < target) left = m + 1;
        else right = m - 1;
    }

    return -1;
}
\end{lstlisting}
    

\section{Абстрактни типове от данни}
\subsection{Дефиниция и идея}
Често при програмирането използваме отделни компоненти наготово, без да ни интересува как точно си вършат работата.
Казваме, че такива компоненти са \textbf{абстракции}. Абстракциите улесняват писането на софтуер, като не ни карат 
да мислим за ненужни детайли.

Абстрактен тип данни е тип данни, който единствено дефинира какви операции поддържа и какъв \textbf{underlying} тип данни ползва.

\subsection{Интерфейс и реализация}
Поддържаните операции от някой абстрактен тип се наричат негов \textbf{интерфейс}. Интерфейсът е това, което клиентския код 
вижда и ползва.

\section{Свързани списъци}
\subsection{Дефиниция и структура}
TODO

\subsection{Обработка на списъци}
TODO

\section{Структура от данни стек}
\subsection{Дефиниция и структура}
TODO

\subsection{Реализация}
TODO

\section{Структура от данни опашка}
\subsection{Дефиниция и структура}
TODO

\subsection{Реализация}
TODO

\section{Дървета}
\subsection{Дефиниция и структура}
TODO

\subsection{Типове дървета}
TODO

\section{Сортиране}
\subsection{Дефиниция}
TODO

\subsection{Елементарни методи за сортиране}
TODO

\subsection{Сортиране - QuickSort}
TODO

\end{document}
