\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{indentfirst}
\usepackage{enumitem, hyperref}
\usepackage{blindtext}
\usepackage{multicol}

\usepackage{tikz}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}

\title{Тема 7\\ Процеси и комуникация между тях в операционата система}
\author{v1.0}
\date{20 юни 2021}

\begin{document}

\maketitle

\tableofcontents
\pagebreak

\section{Основни абстракции}

\subsection{Файлове}

В Unix всичко е файл с изключение на процесите. Те могат да бъдат класифицирани като:
\begin{itemize}
    \item \textit{Обикновени (Regular) файлове} - съдържат обикновени данни, като примери са текстови и бинарни файлове, стандартен вход и изход за процеси.
    \item \textit{Директории} - файлове, които са списъци от други файлове
    \item \textit{Специални файлове} - обозначават входни/изходни устройства, като обикновено се намират в `/dev` директорията.
    \item \textit{Линкове} - връзки към други файлове от дървото на файловата система.
    \item \textit{Сокети} - файлове използвани за inter-process networking. (подобни на TCP/IP сокетите)
    \item \textit{Именувани тръби (Named pipes)} - файлове използвани за еднопосочно \textit{IPC (Inter-Process Communication)}.
\end{itemize}

Метаданни за всеки файл се съхраняват в структури от данни наречени \textit{inode}-ове.
Те съдържат информация като \textit{UID} на собственика, права за достъп, размер на файла, последна дата на модификация и др.

\subsection{Процеси}

Процесът е инстанция (изпълнение) на компютърна програма, която чете и пише файлове и обработва информацията получена от тях.
Той се имплементира като абстракция от ОС, която се грижи за това да предостави единен интерфейс за работа с хардуера, както и да ограничава (квотира) и изолира процесите.

\subsection{Комуникационни канали}

Комуникационните канали са абстракции, имплементирани от ОС, които предават данни от един към друг процес имплементирайки \textit{IPC}.
Всеки канал има край за писане и край за четене като данните се пренасят под формата на поток от байтове.
В \textit{Unix} каналите са два вида - \textit{named}  и \textit{unnamed pipes}.
Синхронизацията между процесите се извършва посредством имплементация на решението на \textit{Producer-Consumer} проблема чрез семафори.
Освен комуникационни канали за \textit{IPC} могат да се използват \textit{shared memory}, \textit{message passing} и \textit{socket}-и.

\subsection{Имена}

Задача на операционата система е да именува пронстранства от паметта по такъв начин, че те да могат да бъдат адресирани и обхождани.
С имената се бележат поредици от байтове, които принадлежат на един сегмент от паметта.
Когато потребителят търси обект, той използва името му като негов индентификатор.
При връзка с нов обект на него му се дава име, за да може операционата система да го реферира чрез него.

\subsection{Хардуерни абстракции}

ОС абстрахира хардуера чрез унифициран интерфейс, така че процесите да са максимално независими от него.

\subsection{Програмни интерфейси}

ОС доставя интерфейси за работа както с хардуера, така и със своите абстракции.
Някои от тези интерфейси се имплементират стриктно посредством системни извиквания, които комуникират директно с \textit{kernel}-ските модули.
В ОС като GNU са налични библиотеки като \textbf{glibc}, която е обвивка от \textbf{C} функции около системните извиквания.
Освен чрез системни извиквания ОС може да се утилизира и чрез директни извиквания към \textit{kernel}-ските модули, чиито интерфейси често са нестабилни.

\section{Комуникация между процеси чрез споделена памет}

ОС се грижи процесите да бъдат изолирани от гледна точка на памет, но понякога се налага да комуникират (IPC или inter-process communication).
Един начин за имплементация на това е чрез използване на споделена памет (\textit{shared memory}).
Тя се имплементира като ОС заделя зона от оперативната памет, която е достъпна от други процеси.
Споделената памет е много бърза, но при нея могат да настъпят редица синхронизационни проблеми.

\subsection{Съревнование за ресурси/Race condition}

\textit{Race condition} се получава, когато поне два процеса, използващи обща споделена памет, се опитат да я променят използвайки неатомарни операции.
Така това води до повреди в данните.
Начин за справяне с този проблем е чрез използване на конструкцията mutex, чрез която може да се симулира ``атомарна'' операция състояща се от няколко атомарни операции.

\subsection{Критична секция}

\textit{Race condition} настъпва в така наречените критични секции на процесите.
Критична секция е част от процес, където се нарушава инвариантата на дадено парче памет/структура.
В края на критичната секция отново структурата трябва да изпълнява инвариантата си.
Race condition настъпва, когато ОС прекъсне процес докато е в критичната си секция, за да поднови друг който също е в критичната си секция и модифицира същата споделена памет като прекъснатия.

\subsection{Проблеми при некоректна синхронизация}


\subsubsection{Мъртва хватка(Deadlock)}

\textit{Deadlock} се получава, когато един процес се конкурира с друг за повече от един ресурс.
Пример за \textit{deadlock} е когато процес \textbf{$p_1$} е резервирал ресурс \textbf{A} и се нуждае от ресурс \textbf{B}, докато процес \textbf{$p_2$} е резервирал ресурс \textbf{B} и се нуждае от ресурс \textbf{A}.
В тази ситуация и двата процеса са блокирани, изчаквайки другия да освободи ресурса, от който се нуждаят.
Може да се изобрази чрез следния граф:


\begin{center}
\begin{tikzpicture}[main/.style = {node distance={30mm}, draw, circle}] 
\node[main] (1) {$p_1$}; 
\node[main] (2) [above right of=1] {$A$};
\node[main] (3) [below right of=1] {$B$};
\node[main] (4) [below right of=2] {$p_2$};
\draw[->] (1) -- node[midway, above, sloped] {waiting for} (3);
\draw[->] (3) -- node[midway, above, sloped] {assigned to} (4);
\draw[->] (4) -- node[midway, above, sloped] {waiting for} (2);
\draw[->] (2) -- node[midway, above, sloped] {assigned to} (1);
\end{tikzpicture} 
\end{center}

При процеси, за които се знае от какви ресурси се нуждаят, може да се избегне \textit{deadlock} чрез пренареждане на ресурсите им.
Пример за това е задачата за хранещите се философи (\textit{dining philosophers problem}), където философите съответстват на процеси и всеки един от тях е инструктиран да:
\begin{itemize}
    \item мисли докато лявата вилица стане свободна и когато е, да я вземе
    \item мисли докато дясната вилица стане свободна и когато е, да я вземе
    \item да яде за определено време
    \item да освободи дясната вилица
    \item да освободи лявата вилица
    \item повтори отначало
\end{itemize}

Така накрая никой няма да може да вземе две вилици за да започне да яде и системата няма да прогресира.
При определени варианти е възможно ако не се стигне до deadlock да има наличие на starvation.
Възможни решения са 

\begin{itemize}
    \item номериране на всяка вилица с номера от 1 до 5 и инструктиране на всеки философ да взима тази с най-малко число първо. (не винаги е приложим)
    \item въвеждане на арбитър (намален паралелизъм)
    \item лимитиране на броя на философите на масата (не е много бързо)
\end{itemize}

При процеси, които не знаят от какви ресурси, ще се нуждаят предварително се приема друг подход.
Например при базите от данни при наличието на \textit{deadlock}, засегнатите процеси (транзакции) прекъсват и се повтарят отново след известно време.
Администраторите на бази от данни трябва да следят дали в някоя секция не се образуват твърде много \textit{deadlocks}.

\subsubsection{Жива хватка(Livelock/Starvation)}

При \textit{starvation} процесите не са блокирани, но поради по-нисък приоритет, допълнителни условия или изчакване на безкраен поток от друг вид приоритети, някои процеси никога не успяват да получат достъп до ресурса, за който чакат.
Такива процеси ще бъде приспани завинаги.

\section{Синхронизации от ниско ниво}

За решение на проблема с критичните секции, могат да се използват хардуерни инструкции.
В еднопроцесорни среди е достатъчно да се предотвратят прекъсванията, докато процес е в критичната си секция.
Това може да се постигне чрез обграждането на критичната секция с enable/disable interrupts команди.
Това обаче не е решение при наличие на повече процесори.

\subsection{Spinlock}

Решение на този проблем при наличие на много процесори е да се използва \textit{spinlock}.
Чрез него може да се имплементира ``\textit{mutex}'', където докато един процес използва защитения ресурс, то другите чакащи за достъп до него циклят до неговото освобождаване.
Оттам идва и името ``spin'' (въртя) + ``lock'' (заключвам).
\bigbreak
Възможни имплементации на \textit{spinlock} са:
\begin{itemize}
    \item \textit{test-and-set (TAS) spinlock} (\href{https://geidav.wordpress.com/2016/03/23/test-and-set-spinlocks/}{линк към статия}) - имплементира се чрез атомарна \textbf{testAndSet} функция, която присвоява true на булева променлива и връща старата ѝ стойност. Примерен псевдокод е: \\
    \begin{lstlisting}[language=C++, caption=TAS]
bool lock = false;

atomic bool testAndSet(bool& target) {
    bool old = target;
    target = true;
    return old;
}

void enter() {
    while(testAndSet(lock)); // lock must be false to continue
}

void exit() {
    lock = false;
}

void proc() {
    enter();
    // critical section
    exit();
}
    \end{lstlisting}
    \item \textit{atomic swap spinlock} - като \textit{TAS} само, че:
    \begin{lstlisting}[language=C++, caption=Atomic swap]
bool lock = false;

void enter() {
    bool key = true;
    while (key) { atomic_swap(key, lock); }
}

void exit() {
    lock = false;
}

void proc() {
    enter();
    // critical section
    exit();
}
    \end{lstlisting}
    \item \textit{ticket spinlock} (\href{https://geidav.wordpress.com/2016/04/09/the-ticket-spinlock/}{линк към статия}) - имплементира се като \textit{TAS}, но използва опашка за да избягва \textit{starvation}.

\end{itemize}

Едно време единственият начин за имплементация на \textit{spinlock} е бил чрез \textit{assembler} инструкции защото единствено те са били атомарни.
Днешно време се поддържат атомарни операции в езици като \textit{C/C++}, които позволяват имплементацията на \textit{spinlock} по преносим начин.

\section{Синхронизации от високо ниво}

Синхронизациите от по-високо ниво са софтуерни решения, надграждащи над хардуерните.

\subsection{Приспиване и събуждане на процеси}

Приспиване и събуждане (\textit{block and wakeup}) се осъществяват чрез \textit{kernel}-ски команди.
При приспиване на процес, той бива премахнат от колекцията от процеси борещи се за процесорно време.
Спящ процес, може да бъде събуден единствено тогава когато получи сигнал за събуждане от друг процес с права за това. (\textit{като в спящата красавица})

\subsection{Семафори}

Семафорите са механизми за синхронизация от високо ниво.
Те служат за налагането на някаква подредба във времето на изпълнението на инструкциите на процесите.
Измислени са от Дейкстра, като те заимстват механиката си от ЖП семафорите използвани за дирижиране на влаковете.

Семафората се състои от брояч и колекция, в която се съхранява информация за приспаните процеси.
Брояча показва броя на оставащите процеси, които даден семафор ще позволи да преминат през него преди да бъде блокиран.
Когато процес се опита да усвои семафор, то броячът се декрементира и:
\begin{itemize}
    \item ако броячът е $> 0$, то семафорът пропуска процеса към критичната му секция.
    \item ако брояча е $\leq 0$, то процесът бива приспан и прибавен към колекцията.
\end{itemize}
Когато процес се опита да освободи семафор, то броячът се инкрементира и:
\begin{itemize}
    \item ако броячът е $\geq 0$, то нищо не се случва
    \item ако броячът е $< 0$, то бива събуден процес от колекцията, като той се премахва от нея.
\end{itemize}

Информацията за приспаните процеси не се съдържа в \textit{kernel}-а, а в самия семафор.
\bigbreak
В зависимост от вида на колекциите, която използват семафорите, те се разделят на два типа:

\begin{itemize}
    \item \textbf{силен семафор} - имплементиран е с обикновена опашка. Това е справедлив семафор, в който реда на процесите се определя от реда им на достигане до семафора.
    \item \textbf{слаб семафор} - всеки семафор имплементиран със структура различна от обикновена опашка. Поради съществуването на приоритет или някаква друга логика, която променя реда на изпълнение на процесите, може да се получи гладуване.
\end{itemize}
    
Семафорите могат да бъдат изграждани чрез \textit{spinlocks} (рядко) или други механизми като например \textit{sys\_futex} в \textit{Linux}.
Когато не са изградени, чрез \textit{spinlocks} семафорите обичайно функционират по обратния начин на тях, т.е. пестят процесорно време когато някой процес изчаква за достъп до защитен ресурс.

\subsection{Основни функции на семафорите}

Семафорите се употребяват чрез три основни функции:

\begin{itemize}
    \item \textbf{init(counter)} - инициализатор, определящ първоначалната стойност на брояча.
    \item \textbf{wait()} - проверява дали на процеса му е позволено да премине, като ако броячът е $\leq 0$, то този процес бива приспан. Броячът се декрементира.
    \item \textbf{signal()} - сигнализира за освобождаването на семафора, като ако има приспани процеси в колекцията, следващия по ред от тях бива събуден. Броячът се инкрементира.
\end{itemize}

\subsection{Mutex}

\textit{Mutex} е специален вид семафор, където броячът е инициализиран с 1.
Той служи за предпазване на споделената между процеси памет, като в даден момент може да съществува само един процес, който я достъпва.
Всяко обръщение към споделената памет трябва да бъде оградено в mutex-a, за да бъде предпазено.

\section{Комуникационна тръба чрез семафори}

\subsection{Тръба чрез редуване на процесите}
\begin{multicols}{2}
    Consumer

    \dots

    sConsumer.wait()
    
    b = sharedData
    
    sProducer.signal()
    
    \dots

\columnbreak
    Producer
    
    \dots
    
    sProducer.wait()
    
    sharedData = b
    
    sConsumer.signal()
    
    \dots

\end{multicols}

Нека имаме два процеса \textbf{Consumer} и \textbf{Producer} с разписаната по горе критична секция.
Нека имаме съответно и два семафора \textbf{sConsumer} и \textbf{sProducer}, инициализирани съответно с 0 и 1.
Критичната секция на \textbf{Producer} ще се изпълни първа, а после тази на \textbf{Consumer}, защото \textbf{sProducer} е инициализиран с 1, а \textbf{sConsumer} с 0.
Това е и логично защото преди да се изконсумира нещо, то първо трябва да бъде създадено.
Ако тези два процеса се изпълняват последователно в безкраен цикъл, то те ще се редуват прехвърляйки един елемент информация от \textbf{Producer} към \textbf{Consumer} при всяко завъртане.
Това е бавен вариант за осъществяване на тръба, защото твърде много процеси биват приспивани и събуждани.

\subsection{Тръба с буфер от n елемента}
    Имплементира се чрез решението на проблема \textit{Consumer-Producer}.

    \begin{multicols}{2}
        Consumer
    
        \dots
    
        sConsumer.wait()

        mConsumer.wait()
        
        Q.Pop()

        mConsumer.signal()
        
        sProducer.signal()

        \dots
    
    \columnbreak
        Producer
        
        \dots
        
        sProducer.wait()

        mProducer.wait()
        
        Q.Push(\dots)

        mProducer.signal()
        
        sConsumer.signal()

        \dots
    
    \end{multicols}


    Нека имаме два процеса съдържащи горепосочената секция от инструкции, където:
    \begin{itemize}
        \item \textbf{mConsumer} и \textbf{mProducer} са \textit{mutex}-и.
        \item \textbf{Q[n]} - опашката от споделена памет.
        \item \textbf{sProducer} и \textbf{sConsumer} са семафори, които са инициализирани съответно като:
        \begin{itemize}
            \item \textbf{sProducer = init(n)} - семафора инициализирана с размера на опашката.
            \item \textbf{sConsumer = init(0)} - семафора инициализирана с 0, т.е. консуматора не може да чете преди да има нещо продуцирано.
        \end{itemize}
    \end{itemize}

\end{document}
