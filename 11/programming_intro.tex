\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}

\usepackage[dvipsnames]{xcolor}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}


\title{Процедурно програмиране - основни информационни и алгоритмични структури (на базата на C++)}
\author{v1.0}
\date{19 юни 2021}

\begin{document}

\maketitle

\tableofcontents
\pagebreak

\begin{flushleft}

\section{Скаларни типове от данни}

\textit{\textbf{Деф}} - Тип данни наричаме \textbf{скаларен} ако той се състои само от една компонента, т.е. е атомарен. Например числови и булеви типове. \\
\textit{\textbf{Деф}} - Тип данни наричаме \textbf{съставен} ако той се състои от много компоненти. Например масиви. \\
\textit{\textbf{Деф}} - Тип данни наричаме \textbf{примитивен} когато той директно съдържа стойността. \\
\textit{\textbf{Деф}} - Тип данни наричаме \textbf{указател} ако той съдържа адреса към локацията в паметта където се пази стойността. \\

\subsection{Логически тип}

\textit{\textbf{Деф}} - Логическия (булевият) тип данни е скаларен тип от данни, чийто множество от допустими ст-сти е $\{true, false\}$, т.е. истина или лъжа. 
Променливите от този тип се наричат булеви.
\bigbreak
В \textit{C++} булевите променливи се означават чрез ключовата дума \textit{bool} и заемат по 1b. Примери за дефиниция са:

\begin{lstlisting}[language=C++, caption=Bool variables]
int main()
{
    bool a; // when the var is not initialized it is undefined by default
    bool b = false;
}
\end{lstlisting}

В \textit{C++} булевите променливи се представят вътрешно като числа 0 за \textit{false} или 1 за \textit{true}.
Следните оператори могат да бъдат прилагани над булеви променливи:

\begin{lstlisting}[language=C++, caption=Bool operators]
#include <iostream>

int main()
{
    bool a = true;
    bool b = false;

    // Logical AND
    a && a; // true
    a && b; // false
    b && a; // false
    b && b; // false

    // Logical OR
    a || a; // true
    a || b; // true
    b || a; // true
    b || b; // false

    // Logical negation
    !a; // false
    !b; // true

    // Comparison operators where the operand codes are compared
    a == a; a == b; // is equal -> true, false
    a != a; a != b; // is not equal -> false, true
    a > a; a > b; b > a; b > b; // greater than -> false, true, false, false
    a >= a; a >= b; b >= a; b >= b; // greater than or equal to -> true, true, false, true
    a < a; a < b; b < a; b < b; // less than -> false, false, true, false
    a <= a; a <= b; b <= a; b <= b; // less than or equal to -> true, false, true, true

    // IO streams
    // std::cin >> a; -> not allowed
    std::cout << a; std::cout << (a && b); // sends the internal code of the boolean expression to the stdout fd -> 1, 0
}
\end{lstlisting}

\subsection{Целочислени типове}

\textit{\textbf{Деф}} - Целочисленият тип от данни е вид скаларен тип от данни, чийто множество от допустими стойности e $\{x_0, x_1, \dots, x_n\}: x_0 < x_1 < \dots < x_n, x_i + 1 = x_{i+1}, \forall i \in [0, n-1]$ и $x_0, x_1, \dots, x_n \in \mathbb{Z}$.
Променливите от този тип се наричат целочислени. Стойностите на $x_0$ и $x_n$ зависят от това колка байта са заделени за променливата.
В паметта целите числа биват представени в двоичен вид чрез последователни битове, като ако типа не е от неотрицателни целочислени числа, то най-старшият бит е заделен за знак.
\bigbreak
В \textit{C++} целочислените променливи се означават чрез ключовите думи \textit{short int, int, long int, long long int} и техните \textit{unsigned} версии, като те заемат съответно по поне 2b, 2b, 4b и 8b в зависимост от \textit{language data} моделът, който от своя страна зависи от шината на дънната платка. Примери за дефиниция са:

\begin{lstlisting}[language=C++, caption=Integer variables]
int main()
{
    int a; // undefined default value
    int b = 5;
}
\end{lstlisting}

Следните оператори могат да бъдат прилагани над целочислени променливи:

\begin{lstlisting}[language=C++, caption=Integer operators]
#include <iostream>

int main() 
{
    int a = 5;
    int b = -10;
    int c = 2;
    int d = 0;

    // Unary (ops with 1 arg)
    +a; -b; // 5, 10
    ++a; a++; // incrementation -> 6, 6
    --a; a--; // decrementation -> -4, -4

    // Binary (ops with 2 args)
    a - b; // 15
    a + b; // -5
    a * b; // -50
    b / a; a / c; // -2, 2
    a % c; // 1

    // Boolean ops
    // Integers different from 0 are interpreted as true
    a && b; a && d; // true, false
    a || d; d || d; // true, false
    !b; !!b; // 0, 1

    // Comparison ops
    a == a; a == b; // is equal to -> true, false
    a != a; a != b; // is not equal to -> false, true
    a > a; a > b; // greater than -> false, true
    a >= a; a >= b; // greater than or equal -> true, true
    a < a; a < b; // less than -> false, false
    a <= a; b <= a; // less than or equal -> true, true

    // IO ops
    std::cin >> a; // read number of stdin fd
    std::cout << a; // sends the number's decimal representation to the stdout fd
}
\end{lstlisting}

\subsection{Реални типове}

\section{Основни структури от данни}
\subsection{Съставни типове от данни}
\subsection{Структура от данни масив}
\subsection{Тип масив}

\section{Тип указател}
\subsection{Дефиниране}
\subsection{Основни операции}
\subsection{Указателна аритметика}
\subsection{Указатели и едномерни масиви}
\subsection{Указатели и двумерни масиви}
\subsection{Указатели и низове}

\section{Функции}
\subsection{Дефиниране на функция}
\subsection{Обръщение към функция}
\subsection{Предаване на параметрите по стойност}
\subsection{Предаване на параметрите чрез указател}
\subsection{Предаване на параметрите чрез псевдоним}
\subsection{Масиви като формални параметри}

\end{flushleft}
\end{document}
