\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}
\usepackage{graphicx}
\usepackage{mathtools}

\usepackage[dvipsnames]{xcolor}

\usepackage{listings}
\usepackage{xcolor}

\graphicspath{ {./img/} }

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}


\title{Процедурно програмиране - основни информационни и алгоритмични структури (на базата на C++)}
\author{v1.0}
\date{19 юни 2021}

\begin{document}

\maketitle

\tableofcontents
\pagebreak

\begin{flushleft}

\section{Скаларни типове от данни}

\textit{\textbf{Деф}} - Тип данни наричаме \textbf{скаларен} ако той се състои само от една компонента, т.е. е атомарен. Например числови и булеви типове. \\
\textit{\textbf{Деф}} - Тип данни наричаме \textbf{съставен} ако той се състои от много компоненти. Например масиви. \\
\textit{\textbf{Деф}} - Тип данни наричаме \textbf{примитивен} когато той директно съдържа стойността. \\
\textit{\textbf{Деф}} - Тип данни наричаме \textbf{указател} ако той съдържа адреса към локацията в паметта където се пази стойността. \\

\subsection{Логически тип}

\textit{\textbf{Деф}} - Логическия (булевият) тип данни е скаларен тип от данни, чийто множество от допустими ст-сти е $\{true, false\}$, т.е. истина или лъжа. 
Променливите от този тип се наричат булеви.
\bigbreak
В \textit{C++} булевите променливи се означават чрез ключовата дума \textit{bool} и заемат по 1b. Примери за дефиниция са:

\begin{lstlisting}[language=C++, caption=Bool variables]
bool a; // when the var is not initialized it is undefined by default
bool b = false;
\end{lstlisting}

В \textit{C++} булевите променливи се представят вътрешно като числа 0 за \textit{false} или 1 за \textit{true}.
Следните оператори могат да бъдат прилагани над булеви променливи:

\begin{lstlisting}[language=C++, caption=Bool operators]
bool a = true, b = false;

// Logical AND
a && a; a && b; b && a; b && b; // true, false, false, false

// Logical OR
a || a; a || b; b || a; b || b; // true, true, true, false

// Logical negation
!a; !b; // false, true

// Comparison operators where the operand codes are compared
a == a; a == b; // is equal -> true, false
a != a; a != b; // is not equal -> false, true
a > a; a > b; b > a; b > b; // greater than -> false, true, false, false
a >= a; a >= b; b >= a; b >= b; // greater than or equal to -> true, true, false, true
a < a; a < b; b < a; b < b; // less than -> false, false, true, false
a <= a; a <= b; b <= a; b <= b; // less than or equal to -> true, false, true, true

// IO streams
// std::cin >> a; -> not allowed
std::cout << a; std::cout << (a && b); // sends the internal code of the boolean expression to the stdout fd -> 1, 0
\end{lstlisting}

\subsection{Целочислени типове}

\textit{\textbf{Деф}} - Целочисленият тип от данни е вид скаларен тип от данни, чийто множество от допустими стойности e $\{x_0, x_1, \dots, x_n\}: x_0 < x_1 < \dots < x_n, x_i + 1 = x_{i+1}, \forall i \in [0, n-1]$ и $x_0, x_1, \dots, x_n \in \mathbb{Z}$.
Променливите от този тип се наричат целочислени. Стойностите на $x_0$ и $x_n$ зависят от това колка байта са заделени за променливата.
В паметта целите числа биват представени в двоичен вид чрез последователни битове, като ако типа не е от неотрицателни целочислени числа, то най-старшият бит е заделен за знак.
\bigbreak
В \textit{C++} целочислените променливи се означават чрез ключовите думи \textit{short int, int, long int, long long int} и техните \textit{unsigned} версии, като те заемат съответно по поне 2b, 2b, 4b и 8b в зависимост от \textit{language data} моделът, който от своя страна зависи от шината на дънната платка. Примери за дефиниция са:

\begin{lstlisting}[language=C++, caption=Integer variables]
int a; // undefined default value
int b = 5;
\end{lstlisting}

Следните оператори могат да бъдат прилагани над целочислени променливи:

\begin{lstlisting}[language=C++, caption=Integer operators]
int a = 5, b = -10, c = 2, d = 0;

// Unary (ops with 1 arg)
+a; -b; // 5, 10
++a; a++; --a; a--; // incrementation and decrementation -> 6, 7, 6, 5

// Binary (ops with 2 args)
a - b; a + b; a * b; b / a; a / c; a % c; // 15, -5, -50, -2, 2, 1

// Boolean ops
// Integers different from 0 are interpreted as true
a && b; a && d; // true, false
a || d; d || d; // true, false
!b; !!b; // 0, 1

// Comparison ops
a == a; a == b; // is equal to -> true, false
a != a; a != b; // is not equal to -> false, true
a > a; a > b; // greater than -> false, true
a >= a; a >= b; // greater than or equal -> true, true
a < a; a < b; // less than -> false, false
a <= a; b <= a; // less than or equal -> true, true

// IO ops
std::cin >> a; // read number of stdin fd
std::cout << a; // sends the number's decimal representation to the stdout fd
\end{lstlisting}

\subsection{Реални типове}

\textit{\textbf{Деф}} - Рационалният тип данни е скаларен тип от данни, чийто множество от допустими стойности е подмножество на някакъв затворен интервал от $\mathbb{Q}$.
Той често бива по грешка наричан реален. Променливите от този тип се наричат рационални (или реални).
Рационалните числа биват записвани като последователност от битове според \textit{IEEE 754}, като 1-вия бит се използва за знак, следващите няколко за експонента и най-младшите за мантиса.
При при 64-битови рационални променливи имаме следното:

\includegraphics[width=\textwidth]{floating_point_num.png}

Стойността на числото се изчислява по формулата $(-1)^{sign} (1.mantissa) 2^{exp - \lfloor max(exp)/2 \rfloor}$, където $sign = b_{63}, exp = b_{62}b_{61} \dots b_{52}, mantissa = b_{51}b_{50} \dots b_{0}$, $max(exp)$ е максималната стойност на $exp$ (при 64-битови числа е 2046) и $b_i$ е битът на позиция $i$.
\bigbreak
Други особености са, че не е комутативен. Също така е препоръчително при сравнения на рационални променливи да се добавя $\varepsilon \in \mathbb{Q}, \varepsilon > 0$ и $\varepsilon$ достатъчно малък за да не наруши необходимата точност.
\bigbreak
В \textit{C++} рационалните променливи се означават чрез ключовите думи \textit{float} и \textit{double}, като те обичайно заемат съответно по 4b и 8b. Примери за дефиниция са:

\begin{lstlisting}[language=C++, caption=Real numbers]
double a; // undefined default value
double b = 5.0;
\end{lstlisting}

Следните оператори могат да бъдат прилагани над рационални променливи:

\begin{lstlisting}[language=C++, caption=Real number operations]
double a = -1.0, b = 5.0, c = 0.0;

// Unary ops are similar to the ones with integers
-a; +a; // ~1.0, ~-1.0
++a; a++; --a; a--; // ~0.0, ~1.0, ~0.0, ~-1.0

// Arithmetics work similar to the ones with integers
a + b; a - b; // ~4.0, ~-6.0
a / b; a * b; // ~-0.2, ~-5.0
// a % b is not allowed

// Boolean ops
// Numbers different from 0.0 are interpreted as true
a && c; a && b; // 0.0, 1.0
a || c; c || c; // 1.0, 0.0
!c; !!c; // 0.0, 1.0

// Comparison ops are the same as with integers

// IO ops
std::cin >> a; // reads the number from the stdin fd
std::cout << a; // sends the number string represenation to the stdout fd
\end{lstlisting}

\section{Основни структури от данни}
\subsection{Съставни типове от данни}

\textit{\textbf{Деф}} - Структурите от данни представляват начин за организация на информация с цел по-ефикасното ѝ използване.

\subsection{Структура от данни масив}

\textit{\textbf{Деф}} - Масивът е крайна редица от фиксиран брой хомогенни елементи, т.е. от един и същи тип, без значение дали е скаларен или съставен.
Всеки елемент е индексиран, което позволява пряк достъп до него.
\bigbreak
Има два вида масиви - статични и динамични.
Към статичните не могат да бъдат добавяни и премахвани елементи, т.е. са статични структури от данни.
При динамичните масиви това е възможно, като обичайно те са имплементират върху статични масиви чрез заделяне динамична памет.
\bigbreak
Елементите на даден масив се заделят последователно в паметта.
Това позволява, използвайки размера на типа им от данни, конкретен такъв да бъде достъпен директно.
\bigbreak
В \textit{C++} масив се дефинира чрез типа масив.

\subsection{Тип масив}

Типът масив се определя чрез задаване на типа и броя на елементите на редицата, определяща масив.
Нека \textbf{T} е име или дефиниция на произволен тип, различен от псевдоним, \textbf{void} и функционален, а \textbf{size} е неотрицателна целочислена променлива.
Тогава \textbf{T[size]} е тип масив от \textbf{size} елемента от тип \textbf{T}.
Елементите се индексират от \textbf{0} до \textbf{size–1}.
\textbf{T} се нарича базов тип, а \textbf{size} – размер/капацитет.

Променлива от тип масив се дефинира по начина \textbf{T <arr\_name>[size] [= \{<comma\_separated\_constanst\_values>\}]} или \textbf{T <arr\_name>[] = \{<comma\_separated\_constanst\_values>\}}.
Примери са:

\begin{lstlisting}[language=C++, caption=Example array definitions]
int a[5]; // array with 5 elements of type int indexed from 0 to 4
double b[10]; // array with 5 elements of type double indexed from 0 to 9

bool c[] = {false, true, false, true, true}; // array with 5 elements of type bool
\end{lstlisting}

Множеството от допустими стойности на типа \textbf{T[size]} се състои от всички редици от по \textbf{size} елемента, които са произволни константи от тип \textbf{T}.
Елементите от множеството от допустими стойности на даден тип масив са константите на този тип масив.
\bigbreak
Елементите на масив с размер \textbf{size} са индексирани поледователно с естественитe числа от \textbf{0} до \textbf{size-1}.
Достъпът до конкретен елемент се осъществява посредством неговата индексирана променлива.
Индексираните променливи имат следния синтаксис \textbf{<indexed\_var> := <arr\_name>[index]}, където \textbf{index} е от целочислен тип.
Пример е:

\begin{lstlisting}[language=C++, caption=Example array item access]
int a[] = {1, 2, 85, 4, 101};

a[0]; a[1]; a[2]; a[3]; a[4]; // 1, 2, 85, 4, 101
// a[5]; yields a segfault error
\end{lstlisting}

\section{Тип указател}
\subsection{Дефиниране}
\subsection{Основни операции}
\subsection{Указателна аритметика}
\subsection{Указатели и едномерни масиви}

Дефиницията на променлива от тип масив заделя памет (обикновено 4b), в която записва адреса в паметта на първата индексирана променлива на масива.
Останалите се достъпват директно, използвайки указателна аритметика и размера на типа от данни на елементите.

\subsection{Указатели и двумерни масиви}
\subsection{Указатели и низове}

\section{Функции}
\subsection{Дефиниране на функция}
\subsection{Обръщение към функция}
\subsection{Предаване на параметрите по стойност}
\subsection{Предаване на параметрите чрез указател}
\subsection{Предаване на параметрите чрез псевдоним}
\subsection{Масиви като формални параметри}

\end{flushleft}
\end{document}
