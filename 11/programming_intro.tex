\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}
\usepackage{graphicx}
\usepackage{mathtools}

\usepackage[dvipsnames]{xcolor}

\usepackage{listings}
\usepackage{xcolor}

\graphicspath{ {./img/} }

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}


\title{Процедурно програмиране - основни информационни и алгоритмични структури (на базата на C++)}
\author{v1.0}
\date{19 юни 2021}

\begin{document}

\maketitle

\tableofcontents
\pagebreak

\begin{flushleft}

\section{Скаларни типове от данни}

\textit{\textbf{Деф}} - Тип данни наричаме \textbf{скаларен} ако той се състои само от една компонента, т.е. е атомарен. Например числови и булеви типове. \\
\textit{\textbf{Деф}} - Тип данни наричаме \textbf{съставен} ако той се състои от много компоненти. Например масиви. \\
\textit{\textbf{Деф}} - Тип данни наричаме \textbf{примитивен} когато той директно съдържа стойността. \\
\textit{\textbf{Деф}} - Тип данни наричаме \textbf{указател} ако той съдържа адреса към локацията в паметта където се пази стойността. \\

\subsection{Логически тип}

\textit{\textbf{Деф}} - Логическия (булевият) тип данни е скаларен тип от данни, чийто множество от допустими ст-сти е $\{true, false\}$, т.е. истина или лъжа. 
Променливите от този тип се наричат булеви.
\bigbreak
В \textit{C++} булевите променливи се означават чрез ключовата дума \textit{bool} и заемат по 1b. Примери за дефиниция са:

\begin{lstlisting}[language=C++, caption=Bool variables]
int main()
{
    bool a; // when the var is not initialized it is undefined by default
    bool b = false;
}
\end{lstlisting}

В \textit{C++} булевите променливи се представят вътрешно като числа 0 за \textit{false} или 1 за \textit{true}.
Следните оператори могат да бъдат прилагани над булеви променливи:

\begin{lstlisting}[language=C++, caption=Bool operators]
#include <iostream>

int main()
{
    bool a = true;
    bool b = false;

    // Logical AND
    a && a; a && b; b && a; b && b; // true, false, false, false

    // Logical OR
    a || a; a || b; b || a; b || b; // true, true, true, false

    // Logical negation
    !a; !b; // false, true

    // Comparison operators where the operand codes are compared
    a == a; a == b; // is equal -> true, false
    a != a; a != b; // is not equal -> false, true
    a > a; a > b; b > a; b > b; // greater than -> false, true, false, false
    a >= a; a >= b; b >= a; b >= b; // greater than or equal to -> true, true, false, true
    a < a; a < b; b < a; b < b; // less than -> false, false, true, false
    a <= a; a <= b; b <= a; b <= b; // less than or equal to -> true, false, true, true

    // IO streams
    // std::cin >> a; -> not allowed
    std::cout << a; std::cout << (a && b); // sends the internal code of the boolean expression to the stdout fd -> 1, 0
}
\end{lstlisting}

\subsection{Целочислени типове}

\textit{\textbf{Деф}} - Целочисленият тип от данни е вид скаларен тип от данни, чийто множество от допустими стойности e $\{x_0, x_1, \dots, x_n\}: x_0 < x_1 < \dots < x_n, x_i + 1 = x_{i+1}, \forall i \in [0, n-1]$ и $x_0, x_1, \dots, x_n \in \mathbb{Z}$.
Променливите от този тип се наричат целочислени. Стойностите на $x_0$ и $x_n$ зависят от това колка байта са заделени за променливата.
В паметта целите числа биват представени в двоичен вид чрез последователни битове, като ако типа не е от неотрицателни целочислени числа, то най-старшият бит е заделен за знак.
\bigbreak
В \textit{C++} целочислените променливи се означават чрез ключовите думи \textit{short int, int, long int, long long int} и техните \textit{unsigned} версии, като те заемат съответно по поне 2b, 2b, 4b и 8b в зависимост от \textit{language data} моделът, който от своя страна зависи от шината на дънната платка. Примери за дефиниция са:

\begin{lstlisting}[language=C++, caption=Integer variables]
int main()
{
    int a; // undefined default value
    int b = 5;
}
\end{lstlisting}

Следните оператори могат да бъдат прилагани над целочислени променливи:

\begin{lstlisting}[language=C++, caption=Integer operators]
#include <iostream>

int main() 
{
    int a = 5, b = -10, c = 2, d = 0;

    // Unary (ops with 1 arg)
    +a; -b; // 5, 10
    ++a; a++; --a; a--; // incrementation and decrementation -> 6, 7, 6, 5

    // Binary (ops with 2 args)
    a - b; a + b; a * b; b / a; a / c; a % c; // 15, -5, -50, -2, 2, 1

    // Boolean ops
    // Integers different from 0 are interpreted as true
    a && b; a && d; // true, false
    a || d; d || d; // true, false
    !b; !!b; // 0, 1

    // Comparison ops
    a == a; a == b; // is equal to -> true, false
    a != a; a != b; // is not equal to -> false, true
    a > a; a > b; // greater than -> false, true
    a >= a; a >= b; // greater than or equal -> true, true
    a < a; a < b; // less than -> false, false
    a <= a; b <= a; // less than or equal -> true, true

    // IO ops
    std::cin >> a; // read number of stdin fd
    std::cout << a; // sends the number's decimal representation to the stdout fd
}
\end{lstlisting}

\subsection{Реални типове}

\textit{\textbf{Деф}} - Рационалният тип данни е скаларен тип от данни, чийто множество от допустими стойности е подмножество на някакъв затворен интервал от $\mathbb{Q}$.
Той често бива по грешка наричан реален. Променливите от този тип се наричат рационални (или реални).
Рационалните числа биват записвани като последователност от битове според \textit{IEEE 754}, като 1-вия бит се използва за знак, следващите няколко за експонента и най-младшите за мантиса.
При при 64-битови рационални променливи имаме следното:

\includegraphics[width=\textwidth]{floating_point_num.png}

Стойността на числото се изчислява по формулата $(-1)^{sign} (1.mantissa) 2^{exp - \lfloor max(exp)/2 \rfloor}$, където $sign = b_{63}, exp = b_{62}b_{61} \dots b_{52}, mantissa = b_{51}b_{50} \dots b_{0}$, $max(exp)$ е максималната стойност на $exp$ (при 64-битови числа е 2046) и $b_i$ е битът на позиция $i$.
\bigbreak
Други особености са, че не е комутативен. Също така е препоръчително при сравнения на рационални променливи да се добавя $\varepsilon \in \mathbb{Q}, \varepsilon > 0$ и $\varepsilon$ достатъчно малък за да не наруши необходимата точност.
\bigbreak
В \textit{C++} рационалните променливи се означават чрез ключовите думи \textit{float} и \textit{double}, като те обичайно заемат съответно по 4b и 8b. Примери за дефиниция са:

\begin{lstlisting}[language=C++, caption=Real numbers]
int main()
{
    double a; // undefined default value
    double b = 5.0;
}
\end{lstlisting}

Следните оператори могат да бъдат прилагани над рационални променливи:

\begin{lstlisting}[language=C++, caption=Real number operations]
#include <iostream>

int main()
{
    double a = -1.0, b = 5.0, c = 0.0;

    // Unary ops are similar to the ones with integers
    -a; +a; // ~1.0, ~-1.0
    ++a; a++; --a; a--; // ~0.0, ~1.0, ~0.0, ~-1.0

    // Arithmetics work similar to the ones with integers
    a + b; a - b; // ~4.0, ~-6.0
    a / b; a * b; // ~-0.2, ~-5.0
    // a % b is not allowed

    // Boolean ops
    // Numbers different from 0.0 are interpreted as true
    a && c; a && b; // 0.0, 1.0
    a || c; c || c; // 1.0, 0.0
    !c; !!c; // 0.0, 1.0

    // Comparison ops are the same as with integers

    // IO ops
    std::cin >> a; // reads the number from the stdin fd
    std::cout << a; // sends the number string represenation to the stdout fd
}

\end{lstlisting}
$\quote spin\quote$

\section{Основни структури от данни}
\subsection{Съставни типове от данни}
\subsection{Структура от данни масив}
\subsection{Тип масив}

\section{Тип указател}
\subsection{Дефиниране}
\subsection{Основни операции}
\subsection{Указателна аритметика}
\subsection{Указатели и едномерни масиви}
\subsection{Указатели и двумерни масиви}
\subsection{Указатели и низове}

\section{Функции}
\subsection{Дефиниране на функция}
\subsection{Обръщение към функция}
\subsection{Предаване на параметрите по стойност}
\subsection{Предаване на параметрите чрез указател}
\subsection{Предаване на параметрите чрез псевдоним}
\subsection{Масиви като формални параметри}

\end{flushleft}
\end{document}
