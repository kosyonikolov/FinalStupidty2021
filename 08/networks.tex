
\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}
\usepackage{indentfirst}

\usepackage[dvipsnames]{xcolor}

\usepackage{amsmath}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}
\renewcommand{\arraystretch}{1.3}         % because math expressions

\title{Тема 8\\ Компютърни мрежи и протоколи – OSI модел. Протоколи IPv4,  IPv6, TCP, HTTP.}
\author{v1.0}
\date{13 юни 2021}

\begin{document}

\maketitle

\tableofcontents
\pagebreak

\section{Модели на организация на мрежовите протоколи}
\subsection{OSI модел - най-обща характеристика на нивата}
\textbf{OSI (Open Systems Interconnection)} моделът е първият опит за изграждане теоретичен модел, описващ принципите на комуникация и устройство на мрежовите протоколи.
Той е въведен от организацията \textbf{ISO}. Основна градивна единица са слоевете, като всеки слой предоставя интерфейс и услуги към слоя над него.

\textbf{OSI} се състои от следните 7 слоя:
\begin{enumerate}
    \item \textbf{Физическия слой} е най-ниският слой от \textbf{OSI} модела. Протоколите от този слой приемат и предават битове от едно устройство в друго, като така те отговарят за
    физическата връзка между върховете в дадена топология. Функциите на физическия слой включват:
    \begin{enumerate}
        \item \textit{синхронизация на битове} - осигурява се чрез общ clock, контролиращ изпраща и получателя.
        \item \textit{честота на изпращане на битове (bit rate control)}
        \item \textit{определяне на мрежовата топология}, т.е. дали е bus, star или mesh
        \item \textit{режим на предаване на битовете} - дали комуникацията е simplex, half-duplex или full-duplex.
        \item \textit{начин на установяване/прекъсване на връзката между устройствата}
        \item \textit{кодиране/декодиране на информацията (в двоичен вид) към и от електрически сигнали}
    \end{enumerate}
    Примери за устройства от физическия слой са хъбовете, модемите и коаксиалните кабели.
    \item \textbf{Каналният слой (Data Link Layer или DLL)} се грижи за безгрешното предаване на данни от едно устройство до друго утилизирайки физическия слой.
    Каналният слой може да бъде разделен на два подслоя \textbf{Logical Link Control (LLC)} и \textbf{Media Access Control (MAC)}.\\
    Отговорност на \textbf{DLL} е да предава пакетите до правилните хостове използвайки техните \textbf{MAC} адреси, които се намират използвайки \textbf{ARP (Address Resolution Protocol)}.\\
    Освен това когато пакет от мрежовия слой пристигне той бива допълнително разбит на кадри (frames) в зависимост от размера на кадрите дефиниран от \textbf{NIC (Network Interface Card)}.\\
    Функциите на каналния слой включват:
    \begin{enumerate}
        \item \textit{разбиване на кадри} чрез поставяне на специални битови последователности в началото и края на всеки кадър.
        \item \textit{физическо адресиране} чрез добавяне на \textbf{MAC} адресите на получателя и/или изпращача в хедърите на всеки кадър.
        \item \textit{контрол над грешките} чрез откриване и предаване отново на счупени и/или загубени кадри.
        \item \textit{контрол над потока от данни} - честотата на получаване на устройствата може да бъде различна и заради това се налага координация над количеството от данни, което 
        може да се предава за даден интервал от време.
        \item \textit{контрол на достъпа} - \textbf{MAC} подслоя се използва за да се определи кой има контрол над даден комуникационен канал в някой момент когато той се използва между много устройства.
    \end{enumerate}
    \textbf{DLL} обичайно се предоставя от \textbf{NIC} и някои драйвери на устройства. Имплементира се от \textbf{Ethernet}, суичовете и бриджовете.
    \item \textbf{Мрежовият слой} отговаря за предаването на данни между хостове от различни мрежи, потенциално различаващи се по физическите и каналните си слоеве.
    Като част от този процес е възможно данните да бъдат фрагментирани под формата на пакети \textbf{(PDU (Protocol Data Unit))}.
    Функциите на мрежовия слой включват:
    \begin{enumerate}
        \item \textit{Маршрутизация} - намиране на най-кратък път от изпращач до получател.
        \item \textit{Логическа адресация} - начин за идентификация на всяко устройство в мрежата. При протокола \textbf{IP} адресите на изпращача и получателя биват поставени в хедъра на пакета.
        \item \textit{Предотвратяване на натоварването на мрежата}
    \end{enumerate}
    Примерни протоколи са \textbf{IP}, \textbf{ICMP} и \textbf{IPSec}.
    \item \textbf{Транспортният слой} отговаря за доставката на съобщение от край-до-край като при някои надеждни протоколи като \textbf{TCP} се цели то да бъде цяло.
    Това се получава като протоколите от този слой разбиват съобщенията получени от сесийния слой на по-малки наречени сегменти и ги препращат към мрежовия слой,
    осигурявайки, че всички части са пристигнали цели и в правилна наредба при получателя. Ако сегмент не е стигнал до дестинацията си, то той бива изпратен отново.
    Казваме, че съобщенията биват доставени от край-до-край защото транспортния слой на изпращача комуникира директно с този на получателя.
    Функциите на транспортния слой включват:
    \begin{enumerate}
        \item \textit{Сегментация и повторно сглобяване} - транспортния слой на изпращача получава съобщението от сесийния слой, разбива го на сегменти, поставяйки в хедъра на всеки метаданни за реда на реасемблиране и ги подава на мрежовия слой.
        Транспортният слой на получателя се грижи за реасемблирането на сегментите на база техните хедъри.
        \item \textit{Адресация на услуги (Service Point Addressing)} - за да бъде доставено съобщението до правилния процес върху дестинацията, транспортният слой добавя порт на дестинацията в хедърите на всеки сегмент.
    \end{enumerate}
    Транспортният слой се имплементира като част от ОС, правеща системни извиквания към процесите. Примери са \textbf{TCP} и \textbf{UDP}.
    \item \textbf{Сесийният слой} предоставя:
    \begin{enumerate}
        \item \textit{Установяване, поддръжка и терминиране на сесии}
        \item \textit{Синхронизация} - процесите могат да добавят контролни точки в данните чрез периодичното им запазване.
        Така след прекъсвания на предаването и/или грешки се избягва загуба или повреда на данните.
        \item \textit{Диалогов контролер} - процесите могат да комуникират в half-duplex или full-duplex режим, като той следи чий ред е да изпраща данни.
        \item \textit{Сигурност (напр. автентикация)}
    \end{enumerate}
    Обичайно се имплементира чрез сокети.
    \item \textbf{Презентационният слой} извлича и манипулира данните от приложния слой за да станат годни за пренос по мрежата. Той предоставя:
    \begin{enumerate}
        \item \textit{Транслация} - Конвертиране на данновия формат.
        \item \textit{Криптиране/Декриптиране}
        \item \textit{Компресия}
    \end{enumerate}
    Примерни протоколи от презентационния слой са \textbf{TLS}, \textbf{SSL}, \textbf{IMAP} и \textbf{FTP}.
    \item \textbf{Приложният слой} представлява съвкупност от протоколи, които се имплементират директно от процесите. Примери са \textbf{HTTP} и \textbf{DNS}.
\end{enumerate}

\subsection{Съпоставка между моделите OSI и TCP/IP}

Моделът \textbf{TCP/IP} за разлика от \textbf{OSI} се състои от 4 слоя:
\begin{enumerate}
    \item \textbf{Мрежови интерфейс (Network interface)} - обхваща функциите на физическия и каналния слой на \textbf{OSI}.
    \item \textbf{Мрежови слой} - съвпада с мрежовия слой на \textbf{OSI}.
    \item \textbf{Транспортен слой} - съвпада с транспортния слой на \textbf{OSI}.
    \item \textbf{Приложен слой} - обхваща функциите на сесийния, презентационния и приложния слой на \textbf{OSI}.
\end{enumerate}

Следователно и при двата модела има наличие на стек от независими протоколи, като те са със сходни функции.

Основните 3 свойства на \textbf{OSI} са, че дефинира услуги, интерфейси и протоколи. Така всеки слой дефинира услуги и интерфейси, чрез които по-горните слоеве да ги достъпят.
По този начин \textbf{OSI} дефинира какво прави всеки слой, а не как го прави. При \textbf{TCP/IP} няма такова разграничение.

Моделът \textbf{OSI}, за разлика от \textbf{TCP/IP} е измислен преди протоколите, които му принадлежат.
Следователно той е по-абстрактен и позовавайки се на open/closed принципа е по-лесно протоколите от него да бъдат подменени.
За разлика от него \textbf{TCP/IP} е нагоден към конкретни протоколи и не позволява тяхната подмяна.

При \textbf{OSI} транспортния слой е само connection-oriented, докато при \textbf{TCP/IP} е едновременно connectionless и connection-oriented. (мисля, че това е грешно щото и двата включват UDP и TCP в транспортния си слой)

\section{IP}

\subsection{IPv4 адресация – класова и безкласова}

\textbf{IPv4} е протокол от мрежовия слой. Следователно негова задача е да предава успешно пакети от източник до получател без значение дали се намират в една мрежа или не.
Това се постига чрез придаването на IP адрес на всеки хост и рутер в мрежата.

При \textbf{IPv4} адресите са 32-битови, като те се разделят на две части - адрес на мрежата и адрес на хоста в мрежата.
Мрежовият адрес заема префикса на адреса, докато останалите байтове се заделят за адресация на хоста.

В зависимост от структурата си \textbf{IPv4} адресите се разделят на класове. Класовете се характеризират с мрежова маска и фиксиран префикс, като важат следните формули:

$num\_network\_bits = num\_mask\_bits - num\_fixed\_bits$ \\
$num\_networks = 2^{num\_network\_bits}$ \\
$num\_host\_bits = 32 - num\_mask\_bits$ \\
$num\_hosts = 2^{num\_host\_bits} - 2$, защото първият адрес е заделен за мрежовия адрес, а посления за broadcast адреса. \\

В \textbf{IPv4} адресите се делят на следните 5 класа:

\begin{itemize}
    \item \textbf{Клас A} - фиксираният префикс е $\textbf{\textcolor{RubineRed}{0}}$, т.е. обхвата на първия октет е $\textbf{\textcolor{RubineRed}{0}0000001 - \textcolor{RubineRed}{0}1111111}$, т.е. е от $\textbf{1 - 127}$. \\
    Subnet маската на клас A по подразбиране е \textbf{255.0.0.0}.\\
    Клас A включва адресите само от \textbf{1.0.0.0} до \textbf{126.255.255.255}, като \textbf{127.x.x.x} е резервиран за loopback адреса, а \textbf{0.0.0.0} е не-рутируем мета-адрес използван по различен начин в зависимост от контекста, като обичайно е за незнаен или невалиден адрес.\\
    Следователно $num\_networks = 2^7 - 2 = 126$ и $num\_hosts = 2^{24} - 2$.
    \item \textbf{Клас B} - фиксираният префикс е $\textbf{\textcolor{RubineRed}{10}}$, т.е. обхвата на първия октет е $\textbf{\textcolor{RubineRed}{10}000000 - \textcolor{RubineRed}{10}111111}$, т.е. е от $\textbf{128 - 191}$. \\
    Subnet маската на клас B по подразбиране е \textbf{255.255.0.0}.\\
    Клас B включва адресите само от \textbf{128.0.0.0} до \textbf{191.255.255.255}.\\
    Следователно $num\_networks = 2^{14}$ и $num\_hosts = 2^{16} - 2$.
    \item \textbf{Клас C} - фиксираният префикс е $\textbf{\textcolor{RubineRed}{110}}$, т.е. обхвата на първия октет е $\textbf{\textcolor{RubineRed}{110}00000 - \textcolor{RubineRed}{110}11111}$, т.е. е от $\textbf{192 - 223}$. \\
    Subnet маската на клас C по подразбиране е \textbf{255.255.255.0}.\\
    Клас C включва адресите само от \textbf{192.0.0.0} до \textbf{223.255.255.255}.\\
    Следователно $num\_networks = 2^{21}$ и $num\_hosts = 2^{8} - 2$.
    \item \textbf{Клас D} - фиксираният префикс е $\textbf{\textcolor{RubineRed}{1110}}$, т.е. обхвата на първия октет е $\textbf{\textcolor{RubineRed}{1110}0000 - \textcolor{RubineRed}{1110}1111}$, т.е. е от $\textbf{224 - 239}$. \\
    Клас D е резервиран за multicasting и няма subnet маска. \\
    Следователно щом данните при multicasting не са насочени към конкретен хост няма нужда от от извличане на host адреси.
    \item \textbf{Клас E} - фиксираният префикс е $\textbf{\textcolor{RubineRed}{1111}}$ и е резервиран за експериментални дейности в бъдещето. \\
    Обхвата на клас E е $\textbf{240.0.0.0 - 255.255.255.254}$. Той не разполага със subnet маска.
\end{itemize}

Недостатък при $IPv4$ адресацията е, че половината адреси са от клас A и се разпределят между 127 автономни системи.
Всяка мрежа трябва да има уникален номер, което води до проблеми при нарастване броя на мрежите.
Този проблем се разрешава, чрез разцепването на една мрежа на подмрежи, като за целта мрежвия префикс се разширява.

В исторически план се оказва, че класовете A, B и C не са достатъчно гъвкави и те биват заменени чрез \textbf{Classless Inter-Domain Routing (CIDR)}, който включва:
\begin{itemize}
    \item \textbf{Variable-Length Subnet Masking (VLSM)} - мрежова маска с произволна дължина, като дължината се записва след IP адреса в следния формат \textbf{x.x.x.x/length}.
    Спомага за по-ефективно ползване на изчерпващите се \textbf{IPv4} адреси.
    \item \textbf{Route summarization} - агрегация на множество последователни подмрежи в супермрежи (supernets).
    Чрез \textbf{VLSM} се постига обобщаване в супермрежи (supernetting), т.е. съкращаване на префикса, което е обратното деленето на подмрежи (subnetting), т.е. увеличаването на префикса.
    Например ако имаме 4 подмрежи от вида $\textbf{224.0.0.0/16}$, $\textbf{224.1.0.0/16}$, $\textbf{224.2.0.0/16}$ и $\textbf{224.3.0.0/16}$, то можем да ги обединим в супермрежата $\textbf{224.0.0.0/14}$.
\end{itemize}

\subsection{Основни характеристики на протокол IPv6}

Протоколът \textbf{IPv6} поддържа основните функционалности на \textbf{IPv4}, но с основната разликата, че e пълен редизайн на \textbf{IPv4} и не е обратно съвместим.

Някои от основните характеристики на \textbf{IPv6} са:
\begin{itemize}
    \item \textit{По-голямо адресно пространство} - При \textbf{IPv6} адресите са 128-битови, което означава че са 4 пъти по-широки от при \textbf{IPv4}, 
    следователно броят им е $2^{96}$ по-голям.
    Това означава, че \textbf{IPv6} поддържа около $3.4 * 10^{38}$ различни адреса.
    Това са ~1564 адреса на квадратен метър от земята и следователно всяко устройство може да разполага със свой уникален \textbf{IPv6} адрес.
    По този начин се решава проблема с изчерпването на всички \textbf{IP} адреси.
    \item \textit{Опростен хедър} - Много от ненужните полета при \textbf{IPv4} са преместени в края на хедъра на \textbf{IPv6}, като те не са задължителни.
    Следователно хедъра е разширяем.
    Така \textbf{IPv6} хедърите \textbf{може} да са около двойно по-големи от \textbf{IPv4} хедърите, при положение, че адресите са 4 пъти по-дълги.
    \item \textit{Комуникация от край-до-край} - Понеже всеки хост има свой уникален IP адрес, той може да траверсира мрежата до всеки друг хост без нужда от \textbf{NAT (Network Address Translation)}.
    \item \textit{Автоматична конфигурация} - \textbf{IPv6} поддържа stateful и stateless автоматична конфигурация на устройствата.
    Така неналичието на \textbf{DHCP (Dynamic Host Configuration Protocol)} не спира комуникацията между мрежите.
    \item \textit{По-бързо рутиране и предаване} - заради съкратения хедър.
    \item \textit{IPSec} - по-сигурен е от \textbf{IPv4}.
    \item \textit{Няма broadcast} - не са специфицирани broadcast адреси в \textbf{IPv6}, като се използва multicast за комуникация с много адреси.
    \item \textit{Anycast} - много хостове могат да получат един и същи \textbf{IPv6} адрес, като пакетите се рутират до най-близкия такъв.
    \item \textit{Мобилност} - позволява на хостовете да се преместват географски, но да задържат своя IP адрес.
    Това се постига чрез ползване на автоматичната конфигурация и допълнителни хедъри.
    \item \textit{Плавен преход от IPv4 до IPv6}
\end{itemize}

\section{TCP – процедура на трикратно договаряне}

Протоколът \textbf{TCP (Transmission Control Protocol)} принадлежи на транспортния слой, като той цели да транспортира по надежден начин потока от байтове получен от по-горните слоеве.
Това се постига чрез записването на поредни номера в хедърите на сегментите. Така дори и да има повторени, загубени или разбъркани пакети, 
данните биват сглобявани по коректен начин при получателя.

Други характеристики на \textbf{TCP} са:
\begin{itemize}
    \item \textbf{full-duplex} комуникацията е разрешена.
    \item \textbf{управление на потока (flow-control)} - синхронизация на скоростта на предаване на данните между изпращача и получателя.
    Постига се чрез полето \textbf{window size}, което определя какво количество данни да бъдат изпратени от изпращача преди да бъде получено потвърждение.
    Първоначалният \textbf{window size} се установява на база на \textbf{MSS (Maximum Segment Size)}
    \item \textbf{statefulness} - обмена на данни се случва след установяване на връзка.
\end{itemize} 

Връзка се установява чрез процедурата \textbf{трикратно договаряне (three-way handshake)}:
\begin{enumerate}
    \item \textbf{SYN} - клиентът праща сегмент с вдигнат \textbf{SYN (Synchronize Sequence Number)} бит съдържащ \textbf{пореден номер (sequence number)} до сървъра, от който започват сегментите, които той ще изпраща.
    \item \textbf{SYN + ACK} - сървърът отговаря със сегмент с вдигнати \textbf{SYN} и \textbf{ACK (Acknowledgement)} битове.
    \textbf{ACK} се използва за потвърждение на първия сегмент изпратен от клиента, а \textbf{SYN} за да се укаже с какъв \textbf{пореден номер} ще започнат сегментите изпращани от получателя.
    \item \textbf{ACK} - клиентът потвърждава, че е получил отговора на сървъра, след което се установява full-duplex връзка и започва преноса на данни.
\end{enumerate}

\section{Хипертекстов протокол HTTP}

Протоколът \textbf{HTTP (HyperText Transfer Protocol)} принадлежи на приложния слой, като се използва предимно за трансфер на хипермедия.
Той имплементира моделът клиент-сървър:
\begin{enumerate}
    \item Клиентът изпраща заявка за ресурс (файл или някакви данни като цяло) към сървър
    \item Сървърът отговаря.
\end{enumerate}
Съобщенията при \textbf{HTTP} се делят на две части - хедър с метаданни и съдържание.

\textbf{HTTP} е \textit{stateless} защото сървърът не пази състояние между две заявки от един и същ клиент.
Въпреки, че е имплементиран често над \textbf{TCP}, който е \textit{stateful}, това не го прави \textit{stateful}, а е просто оптимизация, която цели преизползването на вече отворените връзки между клиент и сървър.
\textbf{HTTP} е независим от транспортния слой и може да се имплементира от който и да е надежден протокол от този слой.
Добра алтернатива е \textbf{RUDP (Reliable UDP)}.

\textbf{HTTP} дефинира 9 метода, които могат да се използват за извършване на действие от конкретен тип върху заявения ресурс:
\begin{itemize}
    \item \textbf{GET} - Заявява репрезентация на конкретен ресурс, като \textbf{GET} заявките трябва да се използват само за извличане на данни.
    \item \textbf{HEAD} - Същия като \textbf{GET}, но без изпращане на съдържание (\textbf{response body}), т.е. само хедър (\textbf{response header}).
    \item \textbf{POST} - На база на \textbf{request body} променя заявения ресурс ако съществува или го създава в противен случай.
    \item \textbf{PUT} - Заменя всяко представяне на указания ресурс с това, което е в \textbf{request body}.
    \item \textbf{PATCH} - Частично модифицира заявения ресурс на база на \textbf{request body}.
    \item \textbf{DELETE} - Изтрива указания ресурс.
    \item \textbf{CONNECT} - Отваря тунел към сървъра, идентифициран от указания ресурс.
    \item \textbf{OPTIONS} - Връща поддържаните \textbf{HTTP} методи за заявения ресурс.
    \item \textbf{TRACE} - Прави тест на пътя към заявения ресурс, т.е. дали сървърът е получил нашето съобщение.
\end{itemize}

\end{document}
