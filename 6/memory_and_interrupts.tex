
\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}
\usepackage{indentfirst}

\usepackage{amsmath}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}

\title{Структура и йерархия на паметта. Сегментна и странична преадресация.
Система за прекъсване – приоритети и обслужване.}

\author{v0.5}
\date{22 юни 2021}

\begin{document}

\maketitle

\tableofcontents

\section{Структура и йерархия на паметта}

\subsection{Дефиниции}
\textbf{Бит} - идва от \textbf{b}inary dig\textbf{it} (двоична цифра). Минималното възможно количество информация - приема стойности единствено 0 и 1.
\textbf{Байт} - поредица от 8 бита.
\textbf{Памет} - хардуер, който може да съхранява информация (битове) във времето.

\subsection{Структура}
Паметта е организирана като едномерен масив от битове, организирани в клетки. На всяка клетка се съпоставя линеен адрес - позицията й в масива, 
следователно адресирането става по клетки, а не по индивидуални битове. Обикновено размера на клетката е един байт.
Всяка клетка може да бъде прочетена и записвана:
\begin{itemize}
    \item при четене се подава адрес на клетка и се връща стойността на клетката
    \item при писане се подава адрес + нова стойност, която се записва в клетката
\end{itemize}

Подаването на адресите и стойностите става по паралелни шини. Адресът определя коя клетка ще се свърже със шината за стойности.

\subsection{Основна памет}
Както името подсказва, това е основната памет, с която процесорът работи - взима от там данни и инструкции. 
В днешно време типични размери са от 8 до 64 гигабайта за лични компютри.
Обикновено технологията е \textbf{dynamic random access memory (DRAM)} - където всеки бит е съставен от транзистор и кондензатор.
Съхраненият бит се определя от заряда на кондензатора. Понеже зарядът плавно "изтича", за запазване на информацията е необходимо
периодично опресняване. Предимството на тази технология е че много битове могат да се реализират на малко място, което прави тази памет евтина.


\subsection{Кеш памет}
Процесорите са напредвали (и продължават) да напредват по-бързо от бързодействието на паметта. Като следствие от това, много често
достъпът до паметта е основното бавещо нещо. За целта са измислени кешове: малки и бързи памети, които да дублират текущо използваните 
стойности от основната памет. Основния принцип на работа е локалността:
\begin{itemize}
    \item \textbf{пространствена} - ако някой адрес е достъпен, то е вероятно в бъдеще и съседните му адреси да бъдат достъпени
    \item \textbf{темпорална} - ако някой адрес е достъпен, то е вероятно той да бъде достъпен отново в бъдеще
\end{itemize}

Кешовете използват друга технология - \textbf{static random access memory (SRAM)}. При нея един бит се реализира с повече транзистори (4 или 6),
но за сметка на това няма нужда от периодично опресняване и също така достъпът е по-бърз. Недостатък е по-ниската гъстота (заради повечето транзистори)
и по-високата цена на бит. Регистрите на процесора също са реализирани със \textbf{SRAM}.

Съвременните процесори обикновено имат кеш на няколко нива. Това се налага заради компромиса големина, скорост на достъп и цена.
Най-бързият кеш се означава с \textbf{L1} и се намира в самото ядро. Разделя се на две: един кеш за инструкции, и един за данни.
Това разделение опростява и ускорява дизайна - може двата кеша да се ползват едновременно.
Следващите нива - \textbf{L2}, \textbf{L3}, понякога и повече - се намират извън ядрата и са по-бавни. 
За сметка на това са по-големи и по евтини (напр. може да ползват вариант на \textbf{DRAM}, а не на по-скъпия \textbf{SRAM}). 
При някои процесори някои \textbf{L2} кешове са споделени между няколко ядра, докато други ядра имат собствен \textbf{L2}.

Размерът на \textbf{L1} кешовете е в диапазона 64-192 KB, а общият размер на \textbf{L2} кешовете е от порядъка на мегабайти.

\subsection{Виртуална памет}
При развитието на компютрите се е стигнало до следният проблем: програмите имат нужда от повече памет, отколкото компютърната система реално има.
Това е изисквало големи програми (или такива, работещи с големи данни) да включват код, който се грижи ръчно да зарежда части от програмата/данните
в основната памет. Добавянето на повече физическа памет е било нежелателно, защото паметта е била сравнително скъпа.

Този проблем се решава с реализирането на \textbf{виртуална памет}, която позволява всяка програма да работи във \textbf{виртуално адресно пространство},
което може да е по-голямо от физическото. Комбинация от хардуер (\textbf{memory managment unit - MMU}) и операционна система превръща 
виртуални адреси във физически. Всичко, което не се побира в основната памет, се записва на вторичната памет (напр. твърд диск) и се 
зарежда в ОП когато е необходимо.

Допълнителна полза на виртуалната памет е, че всеки процес може да си има собствено адресно пространство, което изключва възможността
той да омаже чужда памет.

\subsection{Йерархия на паметта}
Йерархията на паметта се определя от времето за достъп, като наредбата е (от бързи към бавни):
\begin{enumerate}
    \item Регистри
    \item \textbf{L1} кеш
    \item Останлите нива кеш
    \item Основна памет
    \item Вторична/външна памет - твърд диск, SSD
    \item Третична памет - оптични дискове, магнитни ленти
\end{enumerate}

Обикновено с увеличаване на времето за достъп се намалява цената на бит.

\section{Сегментна преадресация}

\subsection{Идея и основание}
Идеята на сегментирането е да разбие линейното адресно пространство (виртуално или физическо) на няколко други линейни пространства,
всяко от които си има начало и големина.
Това позволява различни програми да се ползват различни адресни пространства, както и да се ползват различни сегменти в рамките на една и съща 
програма, спрямо предназначението на данните в тях:
\begin{itemize}
    \item данни
    \item инструкции
    \item стек
\end{itemize}

Всеки сегмент може да расте независимо от останалите и също така може да бъде защитен индивидуално. Например, сегмента с програмен код може
да бъде само за изпълнение, този с константи - само за четене, тези за данни - четене и писане. Сегментите се задават чрез \textbf{дескриптори}
и използват чрез \textbf{селектори}. Дескрипторите се съхраняват в сегментни \textbf{таблици}.

Ще опишем как работи сегментацията при \textbf{x86} архитектурата.

\subsection{Сегментен селектор}
Селекторите са 16-битови и се съхраняват в сегментните регистри (\textit{CS, SS, DS, ES, FS, GS}).
Битовете имат следното предназначение:
\begin{itemize}
    \item $0 \dots 1$ - \textbf{requested privilege level}, желано ниво на достъп
    \item $2$ - указва дали дескриптора е глобалната (0) или локалната (1) таблица
    \item $3 \dots 15$ - индекс на дескриптора в таблицата
\end{itemize}

\subsection{Сегментен дескриптор}
Дескрипторите са с големина 8 байта, като съдържат 32-битово отместване (начало) на сегмента, 16-битов размер, а останалите битове са флагове.
Те показват типа на сегмента, нивото на привилегия, дали размера се мери в байтове или в страници (\textbf{granularity bit}) и други.

\subsection{Сегментни таблици и регистри}
Има два типа таблици - глобална и локална таблица със сегментни дескриптори. Има само една глобална таблица, но може да има няколко локални - 
идеята е всяка програма да си има собствена локална таблица. Адресите и размерите на тези таблици се съхранвят съответно в регистрите 
\textit{GDTR} и \textit{LDTR}. Адресът на локалната таблица трябва да попада в сегмент от глобалната таблица.
Писането и четенето на тези регистри става със специалните инструкции \textbf{LGDT, SGDT, LLDT, SLDT}.

\subsection{Получаване на линеен адрес}
Адресите при сегментиране се определят от сегментен селектор и отместване. За да се определи линейния адрес се минава през следните стъпки:
\begin{enumerate}
    \item Проверява се дали дескриптора се намира в локалната или глобалната таблица
    \item Проверява се дали текущия процес има право да достъп сегмента. Ако не - вдига се грешка.
    \item Проверява се дали отместването е извън сегмента, описан в дескроптора. Ако да - вдига се грешка.
    \item Линейният адрес се получава като към началото на сегмента се добави отместването.
\end{enumerate}

Ако не е включено страницирането, полученият линеен адрес е физически. Ако е включено, полученият адрес е виртуален и се минава 
през таблиците за странициране.

\section{Странична преадресация}
TODO

\subsection{Идея и основание}
TODO

\subsection{Каталог на страниците}
TODO

\subsection{Описател на страница}
TODO

\subsection{Стратегии на подмяна на страниците}
TODO

\section{Прекъсвания}
TODO

\subsection{Структура и обработка}
TODO

\subsection{Типове прекъсвания}
TODO

\subsection{Конкурентност и приоритети}
TODO

\subsection{Обслужване на прекъсванията}
TODO

\subsection{Контролери на прекъсванията}
TODO

\end{document}
