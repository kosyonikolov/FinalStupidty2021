
\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}
\usepackage{indentfirst}

\usepackage{amsmath}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}

\title{Структура и йерархия на паметта. Сегментна и странична преадресация.
Система за прекъсване – приоритети и обслужване.}

\author{v0.5}
\date{22 юни 2021}

\begin{document}

\maketitle

\tableofcontents

\section{Структура и йерархия на паметта}

\subsection{Дефиниции}
\textbf{Бит} - идва от \textbf{b}inary dig\textbf{it} (двоична цифра). Минималното възможно количество информация - приема стойности единствено 0 и 1.
\textbf{Байт} - поредица от 8 бита.
\textbf{Памет} - хардуер, който може да съхранява информация (битове) във времето.

\subsection{Структура}
Паметта е организирана като едномерен масив от битове, организирани в клетки. На всяка клетка се съпоставя линеен адрес - позицията й в масива, 
следователно адресирането става по клетки, а не по индивидуални битове. Обикновено размера на клетката е един байт.
Всяка клетка може да бъде прочетена и записвана:
\begin{itemize}
    \item при четене се подава адрес на клетка и се връща стойността на клетката
    \item при писане се подава адрес + нова стойност, която се записва в клетката
\end{itemize}

Подаването на адресите и стойностите става по паралелни шини. Адресът определя коя клетка ще се свърже със шината за стойности.

\subsection{Основна памет}
Както името подсказва, това е основната памет, с която процесорът работи - взима от там данни и инструкции. 
В днешно време типични размери са от 8 до 64 гигабайта за лични компютри.
Обикновено технологията е \textbf{dynamic random access memory (DRAM)} - където всеки бит е съставен от транзистор и кондензатор.
Съхраненият бит се определя от заряда на кондензатора. Понеже зарядът плавно "изтича", за запазване на информацията е необходимо
периодично опресняване. Предимството на тази технология е че много битове могат да се реализират на малко място, което прави тази памет евтина.


\subsection{Кеш памет}
Процесорите са напредвали (и продължават) да напредват по-бързо от бързодействието на паметта. Като следствие от това, много често
достъпът до паметта е основното бавещо нещо. За целта са измислени кешове: малки и бързи памети, които да дублират текущо използваните 
стойности от основната памет. Основния принцип на работа е локалността:
\begin{itemize}
    \item \textbf{пространствена} - ако някой адрес е достъпен, то е вероятно в бъдеще и съседните му адреси да бъдат достъпени
    \item \textbf{темпорална} - ако някой адрес е достъпен, то е вероятно той да бъде достъпен отново в бъдеще
\end{itemize}

Кешовете използват друга технология - \textbf{static random access memory (SRAM)}. При нея един бит се реализира с повече транзистори (4 или 6),
но за сметка на това няма нужда от периодично опресняване и също така достъпът е по-бърз. Недостатък е по-ниската гъстота (заради повечето транзистори)
и по-високата цена на бит. Регистрите на процесора също са реализирани със \textbf{SRAM}.

Съвременните процесори обикновено имат кеш на няколко нива. Това се налага заради компромиса големина, скорост на достъп и цена.
Най-бързият кеш се означава с \textbf{L1} и се намира в самото ядро. Разделя се на две: един кеш за инструкции, и един за данни.
Това разделение опростява и ускорява дизайна - може двата кеша да се ползват едновременно.
Следващите нива - \textbf{L2}, \textbf{L3}, понякога и повече - се намират извън ядрата и са по-бавни. 
За сметка на това са по-големи и по евтини (напр. може да ползват вариант на \textbf{DRAM}, а не на по-скъпия \textbf{SRAM}). 
При някои процесори някои \textbf{L2} кешове са споделени между няколко ядра, докато други ядра имат собствен \textbf{L2}.

Размерът на \textbf{L1} кешовете е в диапазона 64-192 KB, а общият размер на \textbf{L2} кешовете е от порядъка на мегабайти.

\subsection{Виртуална памет}
При развитието на компютрите се е стигнало до следният проблем: програмите имат нужда от повече памет, отколкото компютърната система реално има.
Това е изисквало големи програми (или такива, работещи с големи данни) да включват код, който се грижи ръчно да зарежда части от програмата/данните
в основната памет. Добавянето на повече физическа памет е било нежелателно, защото паметта е била сравнително скъпа.

Този проблем се решава с реализирането на \textbf{виртуална памет}, която позволява всяка програма да работи във \textbf{виртуално адресно пространство},
което може да е по-голямо от физическото. Комбинация от хардуер (\textbf{memory managment unit - MMU}) и операционна система превръща 
виртуални адреси във физически. Всичко, което не се побира в основната памет, се записва на вторичната памет (напр. твърд диск) и се 
зарежда в ОП когато е необходимо.

Допълнителна полза на виртуалната памет е, че всеки процес може да си има собствено адресно пространство, което изключва възможността
той да омаже чужда памет.

\subsection{Йерархия на паметта}
Йерархията на паметта се определя от времето за достъп, като наредбата е (от бързи към бавни):
\begin{enumerate}
    \item Регистри
    \item \textbf{L1} кеш
    \item Останлите нива кеш
    \item Основна памет
    \item Вторична/външна памет - твърд диск, SSD
    \item Третична памет - оптични дискове, магнитни ленти
\end{enumerate}

Обикновено с увеличаване на времето за достъп се намалява цената на бит.

\section{Сегментна преадресация}

\subsection{Идея и основание}
Идеята на сегментирането е да разбие линейното адресно пространство (виртуално или физическо) на няколко други линейни пространства,
всяко от които си има начало и големина.
Това позволява различни програми да се ползват различни адресни пространства, както и да се ползват различни сегменти в рамките на една и съща 
програма, спрямо предназначението на данните в тях:
\begin{itemize}
    \item данни
    \item инструкции
    \item стек
\end{itemize}

Всеки сегмент може да расте независимо от останалите и също така може да бъде защитен индивидуално. Например, сегмента с програмен код може
да бъде само за изпълнение, този с константи - само за четене, тези за данни - четене и писане. Сегментите се задават чрез \textbf{дескриптори}
и използват чрез \textbf{селектори}. Дескрипторите се съхраняват в сегментни \textbf{таблици}.

Ще опишем как работи сегментацията при \textbf{x86} архитектурата.

\subsection{Сегментен селектор}
Селекторите са 16-битови и се съхраняват в сегментните регистри (\textit{CS, SS, DS, ES, FS, GS}).
Битовете имат следното предназначение:
\begin{itemize}
    \item $0 \dots 1$ - \textbf{requested privilege level}, желано ниво на достъп
    \item $2$ - указва дали дескриптора е глобалната (0) или локалната (1) таблица
    \item $3 \dots 15$ - индекс на дескриптора в таблицата
\end{itemize}

\subsection{Сегментен дескриптор}
Дескрипторите са с големина 8 байта, като съдържат 32-битово отместване (начало) на сегмента, 16-битов размер, а останалите битове са флагове.
Те показват типа на сегмента, нивото на привилегия, дали размера се мери в байтове или в страници (\textbf{granularity bit}) и други.

\subsection{Сегментни таблици и регистри}
Има два типа таблици - глобална и локална таблица със сегментни дескриптори. Има само една глобална таблица, но може да има няколко локални - 
идеята е всяка програма да си има собствена локална таблица. Адресите и размерите на тези таблици се съхранвят съответно в регистрите 
\textit{GDTR} и \textit{LDTR}. Адресът на локалната таблица трябва да попада в сегмент от глобалната таблица.
Писането и четенето на тези регистри става със специалните инструкции \textbf{LGDT, SGDT, LLDT, SLDT}.

\subsection{Получаване на линеен адрес}
Адресите при сегментиране се определят от сегментен селектор и отместване. За да се определи линейния адрес се минава през следните стъпки:
\begin{enumerate}
    \item Проверява се дали дескриптора се намира в локалната или глобалната таблица
    \item Проверява се дали текущия процес има право да достъп сегмента. Ако не - вдига се грешка.
    \item Проверява се дали отместването е извън сегмента, описан в дескроптора. Ако да - вдига се грешка.
    \item Линейният адрес се получава като към началото на сегмента се добави отместването.
\end{enumerate}

Ако не е включено страницирането, полученият линеен адрес е физически. Ако е включено, полученият адрес е виртуален и се минава 
през таблиците за странициране.

\subsection{Фрагментация}
При използване на сегментиране без странициране, може да възникне проблема с \textbf{външна фрагментация}. 
Цели сегменти се зареждат в паметта от диска и обратно. При този процес може да се окаже, че има достатъчно свободна 
памет за зареждане на определен сегмент от диска, но няма една "дупка" с достатъчно голям размер. В този случай
операционната система трябва да премести други сегменти, за да дефрагментира паметта и да зареди новия сегмент,
което е сравнително скъпа операция.

\section{Странична преадресация}

\subsection{Идея и основание}
Това е оригиналната идея за виртуална памет. Виртуалното адресно пространство се разделя на \textbf{страници} с еднакъв размер.
Физическото адресно пространство се разделя на блокове със същия размер. Преобразуването на виртуален във физически адрес 
става чрез таблица, описваща коя виртуална страница къде е - в паметта или на диска. Ако се достъпи страница, която не 
е в паметта, се генерира \textbf{page fault}, при който ОС я зарежда от диска, след което програмата продължава от същото място.
Това позволява програмите да ползват адресно пространство, ограничено единствено от ширината на адресите.

Целият механизъм е "прозрачен" за програмите и програмистите. Допълнително предимство е, че може да се осигури защита на данните,
както и напълно да се премахне възможността процес да пише в памет на друг процес.

\subsection{Описател на страница}
Описателят на страниците е 4 байта и съдържа няколко полета:
\begin{itemize}
    \item Флаг, показващ дали страницата е заредена в паметта
    \item \textbf{Dirty} флаг - показва дали страницата е променена от момента на зареждане досега
    \item Адрес на страницата, подравнен на 4 KB
    \item Контролни флагове
\end{itemize}

При \textbf{x86} ако страницата не налична, хардуера игнорира останалите битове. Това позволява на ОС да записва
къде на диска се намира страницата.

\subsection{Каталог на страниците}
Описателите на страниците се съхраняват във \textbf{таблици}, като всяка съдържа 1024 елемента. 
Адресите на таблиците се съхранвят в \textbf{каталог}, който също съдържа 1024 елемента.
Адресът на каталога се съхранява в системния регистъра \textit{CR3}.

\subsection{Транслация}
Процесът на превръщане на виртуален във физически адрес се нарича \textbf{транслация} и се извърщва от хардуер - \textbf{MMU}.
Линейният 32 битов адрес се разбива на три части: старшите 10 бита служат за индекс в каталога, следващите по старшина
10 бита служат за индекс в таблицата, и останалите най-младши 12 се използват като отместване спрямо началото на страницата.

Ако страницата не е в паметта, вдига се \textbf{page fault}, при който ОС трябва да я зареди от диска. В случай че няма свободно място
в основната памет, трябва да се избере някоя заредена страница, която да се премахне. Тук е полезен 
\textbf{dirty} флага - ако избраната страница е "чиста", няма нужда да се запише на диска - копието й там е същото.

При 64 битов режим на работа се добавя още един каталог "отпред", който съдържа адреси на каталози. Така може да се адресират 
повече от $2^32$ байта памет.

\subsection{Стратегии на подмяна на страниците}
Важна част от страницирането е алгоритъма, който избира коя страница трябва да се премахне при \textbf{page fault}.
Два основни алгоритъма са:
\begin{itemize}
    \item \textbf{Least Recently Used} - избира се страницата, която е ползвана най-отдавна
    \item \textbf{First In, First Out} - избира се страницата, която е заредена най-отдавна
\end{itemize}

За съжалание, и двата алгоритъма е възможно да правят неоптимални избори, ако физическата памет е по-малка от виртуалната 
и да се получи \textbf{thrashing} - постоянно местене на страници между диск и основна памет.

\section{Прекъсвания}

\subsection{Структура и обработка}
Прекъсванията и изключенията сигнализират събития, които изискват обработка от ЦП. Когато се получат,
ЦП спира текущата програма и изпълнява специална програма, предназначена за съответния тип прекъсване.
След приключване на специалната програма, прекъсната програма продължава работа (ако това е възможно).
Често прекъсванията са "прозрачни" - програмата не разбира, че е била прекъсната.

\subsection{Типове прекъсвания}
Прекъсванията са асинхронни - не зависят от програмата, която в момента се изпълнява, защото идват отвън.
Изключенията произлизат от определени инструкции в програмата - т.е. са синхронни спрямо нея.
Ако пуснем една програма 10 пъти, изключенията винаги ще се вдигат на едно и също място, докато прекъсванията
ще са на различни места (ако изобщо се случат).

Работата на прекъснатата програма винаги продължава след прекъсвания. Изкюченията се делят на три типа, 
които определят дали и откъде се продължава работата:
\begin{itemize}
    \item \textbf{traps} (капани) - случват се след изпълнението на дадена инструкция и работата продължава от следващата инструкция.
    Използват се за дебъгване и проверка за \textbf{overflow} при аритметични операции.
    \item \textbf{faults} (грешки) - случват се преди изпълнението на дадена инструкция и ако работата продължи, то това става 
    от същата инструкция. От някои грешки може да се възстанови - например \textbf{page fault}.
    \item \textbf{aborts} (сериозни грешки) - работата не може да се продължи след тях. Не винаги е ясно коя точно инструкция е причинила грешката.
\end{itemize}

Допълнително съществува разделение на маскируеми и немаскируеми прекъсвания. Процесорът може да се настрои да игнорира маскируемити прекъсвания.
Прекъсвания могат да се генерират и софтуерно - чрез \textbf{INT} инструкцията.

\subsection{Конкурентност и приоритети}
Прекъсванията могат да настъпват конкурентно, т.е. в даден момент да се окаже че има няколко прекъсвания, чакащи обработка.
За тази цел се дефинират приоритети на прекъсванията:
\begin{enumerate}
    \item Хардуерен \textbf{reset} или грешка
    \item Капан при смяна на задача
    \item Външна хардуерна намеса (подаден сигнал на пин на процесора)
    \item Капан на предходна инструкция (дебъгване)
    \item Немаскируеми прекъсвания
    \item Маскируеми прекъсвания
    \item \textbf{Code breakpoint fault} ???
    \item Грешки при извличане на следваща инструкция
    \item Грешки при декодиране на следваща инструкция
    \item Грешки при изпълнение на следваща инструкция
\end{enumerate}

\subsection{Обслужване на прекъсванията}
Всяко прекъсване си идва с число, което наричаме негов \textbf{вектор}. То служи като индекс в таблица, 
описваща къде се намират програмите, които обслужват прекъсванията - наричани често \textbf{interrupt handler}
или \textbf{interrupt service routine (ISR)}. При \textbf{x86} таблицата се нарича \textbf{Interrupt descriptor table (IDT)}
и винаги съдържа 256 8-байтови \textbf{дескриптора}. Адресът на тази таблица се записва в регистъра \textbf{IDTR} като двойка
сегментен селектор и отместване.

Дескрипторите съдържат адреса на процедурата (сегментен селектор и отместване в сегмент), както и допълнителни битове,
които указват нивото на защита на \textbf{ISR}-a, дали по време на обработка на прекъсването да са позволени други прекъсвания,
дали има процедура за този вектор и т.н.

Първото нещо, което се случва при обслужване на прекъсвания, е запаметяването на регистрите \textit{EFLAGS}, \textit{CS} и \textit{EIP}.
Това се случва или на същия стек, който прекъснатата програма е ползвала (ако е на същото ниво на привилегия), или на друг стек (при различно ниво).
При приключването на процедурата трите регистъра се възстановяват автоматично от хардуера.

Останалите регистри \textbf{НЕ} се запаметяват автоматично от хардуера. Задължение на \textbf{ISR}-ите е да ги възстановят в изходно състояние,
ако това е желан ефект, разбира се.  

\subsection{Контролери на прекъсванията}
Процесорът има само два хардуерни пина за прекъсвания, но може да трябва да обслужва няколко устройства.
За да се решават конфликти, се ползват \textbf{контролери на прекъсванията}, които определят кое 
устройство кога ще си говори с ЦП. Съответно може да се зададат индивидуални приоритети за всяко устройство.

Първият такъв контролер за \textbf{x86} е \textbf{Intel 8259 / 8259A}. От 486 насам се въвежда нова архитектура - 
\textbf{Advanced Programmable Interrupt Contoler}, към която се произвеждат нови чипове. Двата типа чипове
могат, и продължават, да бъдат използвани съвместно.

\end{document}
