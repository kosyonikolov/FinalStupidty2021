
\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{indentfirst}
\usepackage{enumitem, hyperref}
\usepackage{blindtext}
\usepackage{multicol}

\usepackage{amsmath}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}

\title{Процеси и комуникация между тях в операционата система}
\author{v1.0}
\date{5 юни 2021}

\begin{document}

\maketitle

\tableofcontents

\section{Основни абстракции}

\subsection{Файлове}
    Файловете са абстракция за съхраняването на обособена информация. Служи за постоянно съхраняване на данни. 
    
    Не се съхранява твърде специфична информация - само неща като собственик на файла, права за достъп, т.н.)


\subsection{Процеси}
    Процеса е абстракция, изразяваща обработка на информация. Те трябва да се отделени от хардуера с цел да позволи програмите да са независими от типа хардуер, върху който трябва да се изпълняват. Можем да разглеждаме процеса като виртуална машина, която временно работи върху изчислителната ситема. Всеки процес трябва да бъде стартиран и да му се заделят ресурси - време/памет. Работа е на Операционната система да осигури тези ресурси на процесите. Когато има повече от един активен процес, Операционната система се грижи те да бъдат ограничени и изолирани едни от други, така че да не могат да излязат от предварително заделената им памет. 


\subsection{Комуникациони канали}
    Комуникациионите канали са абстракции, които предават данни между два процеса или процес и друг обект все едно те са поток от байтове
    
    Процесите могат да комуникират също така и чрез споделена памет, но по-често се използват комуникационни канали предоставени от операционната система


\subsection{Имена}
    Задача на операционата система е да именува пронстранства от паметта по такъв начин, че те да могат да бъдат адресирани и обхождани. С имената се бележат поредица от байтове, които принадлежат на един сегмент от паметта. Когато потребителят търси обект, той използва името му като негов индентификатор. При връзка с нов обект на него му се дава име, за да може операционата система да го реферира чрез него.


\subsection{Хардуерни абстракции}
    Операционата система предоставя абстракция на хардуера, така че за потребителя да не вижда особена разлика между различни машини използващи една и съща операционна система.


\subsection{Програмни интерфейси}



\section{Комуникация между процеси чрез споделена памет}
    Операционата система се грижи процесите да бъдат изолирани от гледна точка на памет. Процесите обаче в някой стауци се нуждаят да комуникират помежду си. Това може да се случи чрез коуникациони канали преодставени от операционата система или използвайки споделена памет/структура. Обекта на споделената памет трябва да винаги във валидно състояние, изпълнява инвариантата си.
    
    Споделената памет обаче създава възможности за различни проблеми между процесите, ако не са правилно синхронизирани:


\subsection{Съревнование за ресурси/Race condition}
    Race condition се получава, когато няколко процеса, които използват споделена памет/структура. Ако процедурите не са допълнително синхронизирани е възможно да се повреди споделения ресурс.


\subsection{Критична секция}
    Критична секция е част от процес, където се нарушава инвариантата на дадено парче памет/структура. В края на критичната секция отново структурата трябва да изпълнява инвариантата си отново. Проблема се получава, когато по времето, в което този процес е в критичната си секция, той бъде прекъснат от друг процес, използващ тази споделена памет, то втория процес ще получи структурата във вече повредено състояние.


\subsection{Проблеми при некоректна синхронизация}


\subsubsection{Мъртва хватка(Deadlock)}
    Deadlock се получава, когато един процес се конкурира с друг за повече от един ресурс. Процес A е резервирал ресурс B и се нуждае от ресурс C, докато процес D е резервирал ресурс C и се нуждае от ресурс B, за да продължи. В тази ситуация и двата процеса са блокирани, изчаквайки другия да освободи ресурса, от който се нуждаят. Ако представим процесите и ресурсите като върхове на граф, а ребрата на този граф са в посока от процеса към ресурса, ако този ресурс е запазен и от ресурса към процеса, когато процеса ресурса е необходим на процеса. В този граф Deadlock се представят под формата на ориентиран цикъл.

    При процеси, които си знаят от какви ресурси се нуждаят, може да се направи оптимизация по начина, по който се запазват ресурсите. Ресурсите се пренареждат така че да не се получи Deadlock. Пример за това е задачата за петте философа, където ако един от тях е левичар и се опитва да вземе първо лявата вилица, то се предотвратява да се получи Deadlock. (В тази ситуация обаче може да се достигне до Starvation)

    Процеси, които не знаят от какви ресурси, ще се нуждаят предварително (пример. бази данни), възприемат друг подход. При наличието на Deadlock, засегнатите процеси прекъсват и тези процеси (транзакции в бази от данни) се повтарят отново след известно време. Администраторите на бази от данни трябва да следят дали в някоя секция не се образуват твърде много Deadlocks. 


\subsubsection{Жива хватка(Livelock/Starvation)}
    При Starvation процесите не са блокирани, но поради по-нисък приоритет, допулнителни условия или изчакване на безкраен поток от друг вид приоритети, някой процес никога не успява да получи достъп до ресурса, за който чака. Този процес ще бъде приспан завинаги.


\section{Синхронизации от ниско ниво}
    За да се предотврати нарушаването на инвариантата на структурата, може да се забрани достъпването на програми до този ресурс докато той е в критичната си зона. Такива синхронизации он ниско ниво са чисто хардуерни синхронизации. Понастоящем не се използват самостоятелно, а заедно със софтуерни решения на проблема.


\subsection{Използване на специфични инструкции}
    В еднопроцесни машини възможност за повреда на структурата се случват при прекъсвания (например прекъсвания от таймера, които се опитва да даде време на друг процес с цел създаване на илюзията за множество процеса работещи едновременно). Ако такова прекъсване се случи, докато процес е в критичната си секция, това може да доведе до нарушаване на цялостта на данните. Едно от хардуерните решения на този проблем е използването на специфични команди (enable/disable interupts), които да обграждат критичната секция на процес и да забраняват прекъсвания в този прозорец.


\subsection{Spinlock}
    Друг хардуерен метод за решаването на този проблем е използването на spinlock. Това е специален бит в дадена структура, който служи само за определянето на това дали тази структура по настоящем се използва. Всеки процес, опитващ се да достигне даден ресурс, първо прави проверка какво е състоянието на специалния бит и го сетва, ако е свободен. Ако ресурса не е свободен, процесите изчакват той да се освободи, правайки периодични проверки за това какво е състоянието на структурата.

    За правилното функционирането на spinlocks се нуждаем от специфични команди (test и set), които да служат за изпълняването на проверката и сетването на свободния бит. Тези специфични команди са с цел да се избегне потенциално нов race condition.

    Spinlock е техника, която работи и при многопроцесорни машини. Използва се за в случаи, когато структурите променят статусите си често и бързо. Недостатък на използването само на spinlock като метод за синхронизация е това, че останалите процеси, които чакат за заключения ресурс, продължават да заемат процесорно време. Всички процеси циклят, изчаквайки един да приключи работата си с ресурса.

    Spinlocks се използват за създаването на синхронизации от по-високо ниво.


\section{Синхронизации от високо ниво}
    Синхронизациите от по-високо ниво са софтуерни решения надграждащи над хардуерните. Не се използват чисто софтуерни решение, тъй като те са прекалено сложни.

    
\subsection{Приспиване и събуждане на процеси}
    Приспиване и събуждане (block и wakeup) се осъществяват чрез команди към ядрото на операционата система. При приспиване на процес, той бива премахнат от колекцията от процеси борещи се за процесорно време. Информацията за този процес (състоянието, регистрите, които е използвал) се записват в отделна структура. Процес приспан по този начин, не може да се събуди сам, нуждае се от друг процес да му подаде сигнал за събуждането му.


\subsection{Семафори}
    Семафорите за механизми за високо ниво. Служат за налагането на някаква подредба във времето на изпълнението на инструкциите на процесите.

    Семафора представлява брояч и колекция, в която да се съхранява информация за приспаните процеси. Брояча показва броя на оставащите процеси, които даден семафор ще позволи да преминат през него преди да бъде блокиран. Когато брояча е положителен, семафора пропуска процеси към критичната им секция. Когато брояча стане равен на нула, следвщия процес, обръщаш се към него, бива приспан и прибавен към колекцията от приспани процеси; брояча намалява с единица. Когато брояча е отрицателен, модул от брояча показва броя на приспани процеси колекцията. Информацията за приспаните процеси не се съдържа в ядрото на операционата система, а в самия семафор.

    В зависимост от вида на колекцията, която използва семафора, семафорите се разделят на два типа:

\begin{itemize}
    \item силен семафор - Имплементиран е с обикновенна опашка. Това е справедлив семафор, в който реда на процесите се определя от реда им на достигане до семафора
    \item слаб семафор - Всеки семафор имплементиран със структира различна от обикновенна опашка. Поради съществуването на приоритет или някаква друга логика, която пренарежда реда на изпълнение на процесите, може да се получи гладуване (starvation - ситуация, в която поради безкрае приток на нови процеси пререждащи даден процес, то на този процес никога не му биват предоставени ресурси)
\end{itemize}
    
    Семафорите са изградени чрез spinlock, който се грижи за синхронизацията на достъпа до самия семафор. Това е достатъчно бързо решение за имплементацията на семафорите. Процесите, които искат да използват семафора, циклят, докато той се освободи. Семафора е структура, която се очаква бързо да си променя състоянието, което е точно описанието на това кога се използват spinlocks.


\subsection{Основни функции на семафорите}
    Семафорите предоставят три основни функции:

\begin{itemize}
    \item init(counter) - Инициализатор, определящ първоначалната стойност на брояча
    \item wait() - Проверява дали на процеса му е позволено да премине. Ако брояча е по-малък или равен на нула, този процес бива приспан.
    \item signal() - Използва се на края на критичната секция на даден процес и служи да сигнализира освобождаването на семафора. Ако след освобождаването на семафора има приспани процеси в колекцията, следващия по ред от тях бива събуден. Ако колекцията е празна, брояча на семафора става положителен.
\end{itemize}


\subsection{Mutex}
    Mutex е специалне вид семафор, служещ за предпазване на споделената между процеси памет да не бъде повредена. Mutex-a има брояч с начална стойнсот едно. По всяко време може да съществува само един процес, който да достъпва общата памет; всички останали си чакат реда. Всяко обръщение към споделената памет (get или set операции) трябва да бъде оградено в mutex-a, за да бъде предпазено.


\section{Комуникационна тръба чрез семафори}

\subsection{Тръба чрез редуване на процесите}
\begin{multicols}{2}
    P

    \dots

    sQ.wait()
    
    b = sharedData
    
    sP.signal()
    
    \dots

\columnbreak
    Q
    
    \dots
    
    sP.wait()
    
    sharedData = b
    
    sQ.signal()
    
    \dots

\end{multicols}

Нека имаме два процеса S И Q с разписаната по горе критична секция. Нека имаме съответно и два семафора sP и sQ, единия от които е инициализар с нула другия с единица. В зависимост, кой от двата семафора е инициализиран с единица критичната секция на този процес ще се изпълни първа. Ако тези два процеса се сложат в цикъл, то те ще се редуват до безкрайност прехвърляйки един елемент информация от Q към P при всяко завъртане. Това е бавен вариант за осъществяване на тръба, твърде много процеси биват приспивани и събуждани.


\subsection{Тръба с буфер от n елемента}
    Проблема Consumer-Producer/Reader-Wroter 

    \begin{multicols}{2}
        Reader/Consumer
    
        \dots
    
        write.wait()

        mread.wait()
        
        Q.Get()

        mread.signal()
        
        read.signal()

        \dots
    
    \columnbreak
        Writer/Producer
        
        \dots
        
        read.wait()

        mwrite.wait()
        
        Q.Set(\dots)

        mwrite.signal()
        
        write.signal()

        \dots
    
    \end{multicols}


    Нека имаме два процеса съдържащи горепосочената секция от инструкции. mread и mwite са mutex-и, които предпазват опашката от данни. Q[n] - опашката от споделена памет. read и write са семафори, които са инфиализирани съответно като:
    
    \begin{itemize}
        \item read.init(n) - Семафора е инициализиран с размера на опащката.
        \item write.init(0) - Този семафор е инициализиран с нула' не може да се чете прди да има нещо написано
    \end{itemize}

    В операционната система реализацията на тръби не се случва по този начин. Отново има твърде много прекъсвания и прехвърляния между процесите.

\end{document}