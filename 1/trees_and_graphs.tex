
\documentclass[fleqn,12pt]{article}

\usepackage[margin=1cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}

\usepackage{amsmath}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}

\begin{document}
\pagenumbering{gobble}

\Large\center\textbf{Графи. Дървета. Обхождане на графи.}

\begin{flushleft}

\section{Дефиниции за краен ориентиран (мулти)граф и краен неориентиран (мулти)граф.}
Краен ориентиран мултиграф се нарича тройката $G = (V, E, f_G)$, където
\begin{itemize}
	\item $V = \{ v_1, v_2, \dots, v_n \}$ - върхове
	\item $E = \{ e_1, e_2, \dots, e_m \}$ - ребра
	\item $f_G : E \rightarrow V^2$ - свързваща функция
\end{itemize}
\vspace{10mm}

\textbf{TODO} Неориентиран мултиграф с тези дефиниции
\vspace{10mm}

Нека $G = (V, E, f_G)$ е ориентиран мултиграф. Казваме, че $G$ е просто ориентиран граф, ако $f_G$ е инективна. 
Такива графи означаваме $G = (V, E), E \subseteq V^2$.
\vspace{10mm}

Нека $G = (V, E)$ е ориентиран граф. Казваме, че $G$ е неориентиран, ако релацията $E$ е симетрична и рефлексивна.

\section{Дефиниции за маршрут (контур) в ориентиран мултиграф и път (цикъл) в неориентиран мултиграф.}

Нека $G = (V, E, f_G)$ е краен мултиграф. Маршрут в крайния мултиграф се нарича
редицата $v_{i0} , e_{j1} , e_{j2} , \dots , e_{jL} , v_{iL}$ , където $v_{i0}, v_{iL}$ са върхове, а останалите са ребра. 
$L$ се нарича дължина на маршрута.
\vspace{10mm}

Нека $G = (V, E, f_G)$ е краен мултиграф. Път в графа се нарича всяка редица от вида
$v_{i0}, v_{i1}, \dots, v_{iL}$, за която $\forall p \in \{ 0, 1, \dots, L - 1 \}$ е изпълнено:
\begin{itemize}
	\item $v_{ip} \neq v_{ip+1}$
	\item $\exists e \in E : f_G(e) = (v_{ip}, v_{ip+1})$
\end{itemize}
\vspace{10mm}

Нека $v_{i0}, v_{i1}, \dots, v_{iL}$ е път в крайния мултиграф $G = (V, E, f_G)$.
Казваме, че редицата е цикъл, ако $v_{i0} = v_{iL}$.

\section{Свързаност и свързани компоненти на граф.} 

Нека $G = (V, E)$ е неориентиран граф. 
С $R \subseteq V^2$ обозначаваме релацията $ (u, v) \in R \Leftrightarrow \exists $ път $u, w_0, w_1, \dots, v$ в $G$.
Очевидно $R$ е релация на еквивалентност. Свързани компоненти на $G$ наричаме класовете на еквивалентност на $R$.

\section{Дефиниция на дърво и кореново дърво.}

Нека $G(V, E)$ e неориентиран граф. Казваме, че $G$ е свързан, ако всички негови върхове
се намират в една свързана компонента.
\vspace{10mm}

Нека $G(V, E)$ e неориентиран граф. Казваме, че $G$ е дърво, ако е свързан и не съдържа цикли.
\vspace{10mm}

Кореново дърво наричаме двойката $D(V, E)$, която дефинираме индуктивно:
\begin{itemize}
	\item Двойката $(\{r\}, \varnothing)$ е кореново дърво с корен $r$ и единствено листо $r$.
	\item Нека $D(V,E)$ е кореново дърво с листа $L_0, L_1, \dots, L_k$, $u \in V, v \notin V$. Тогава $D'(V \cup \{v\}, E \cup \{ (v, u)\})$ е кореново дърво.
	Ако $v = L_i$, то листата на $D'$ са $L_0, L_1, \dots, L_{i-1}, v, L_{i+1}, \dots, L_k$. В противен случай листата на $D'$ са 
	$L_0, L_1, \dots, L_k, v$.
\end{itemize}

\section{Доказателство, че всяко кореново дърво е дърво и |V|=|E|+1.}
\textbf{Твърдение:} Всяко кореново дърво $D(V,E)$ е дърво, т.е. свързан ацикличен граф.

\textbf{Доказателство (свързаност)}: Трябва да докажем, че за съществува път между всяка двойка върхове $(u, v) \in V^2$. Достатъчно е да докажем, че 
за всяко $v \in V$ съществува път до коренът $r$. Ако това е вярно, то път между всеки два върха може да се построи с обединяване на двата пътя до корена 
(единият наобратно). Ще докажем, че от всеки връх има път до корена, използвайки индуктивната дефиниция.

\textit{Индукционно предположение:} От всеки връх на $D(V,E)$ (без корена) има път до корена $r$. 
\begin{itemize}
	\item Минималното дърво $(\{r\}, \varnothing)$ има единствен връх самият корен, като редицата $r$ можем да считаме за "път до корена".
	\item Нека $D(V,E)$ е кореново дърво и $u \in V, v \notin V$. Разглеждаме кореновото дърво $D'(V \cup \{v\}, E \cup \{ (v, u)\})$.
	От ИП знаем, че от всяко $w \in V$ има път до корена. Има ребро от върха $v \notin V$ към $u \in V$, но има път от $u$ до корена $\Rightarrow$
	има път от $v$ до корена $\Rightarrow$ От всеки връх от $V \cup \{v\}$ има път до корена $\Rightarrow$ ИП е изпълнено за $D'$.
\end{itemize}

\textbf{Доказателство (ацикличност)}: Нека допуснем, че съществува $D(V,E)$ с цикъл. Тогава съществува поддърво $D'(V', E'), V' \subseteq V, E' \subseteq E$, 
което съдържа листо със степен $>1$ - това листо е връх, участващ в цикъла, с максимална дълбочина (може да са повече от един). Това следствеие се вижда лесно на картинка. 
Но по индуктивната дефиниция за кореново дърво всички листа са със степен 1. Следователно допускането ни, че съществува кореново дърво с цикъл е грешно $\Rightarrow$ всички коренови дървета
са ациклични.
\vspace{10mm}

\textbf{Твърдение:} За всяко кореново дърво $D(V,E)$ е изпълнено $|V| = |E| + 1$.

\textbf{Доказателство:} Отново ще използваме индуктивната дефиниция за кореново дърво.
\begin{itemize}
	\item Двойката $(\{r\}, \varnothing)$ е кореново дърво, $|V| = 1, |E| = 1$.
	\item Нека $D(V,E)$ е кореново дърво, $u \in V, v \notin V$. Тогава $D'(V', E'), V' = V \cup \{v\}, E' = E \cup \{ (v, u)\}$ е кореново дърво.
	Имаме $\Rightarrow |V'| = |V| + 1, |E'| = |E| + 1$, но знаем, че $|V| = |E| + 1 \Leftrightarrow |V| + 1 = |E| + 1 + 1 \Leftrightarrow |V'| = |E'| + 1$.
\end{itemize}

\section{Покриващо дърво на граф.}
Нека $G = (V, E)$ е неориентиран граф. Покриващо дърво на $G$ наричаме всяко дърво $D(V, E'), E' \subseteq E$.
\vspace{10mm}

\textbf{Твърдение:} Неориентиран граф $G = (V, E) \Leftrightarrow $ същестува покриващо дърво $D(V, E' \subseteq E)$ 

\textbf{Доказателство (=>):} Понеже $D$ е дърво, то $D$ е свързан. $D$ е подграф на $G$, но със същото множество върхове $V$, следователно $G$ също е свързан.

\textbf{Доказателство (<=):} Можем да премахнем всички цикли от $G$ чрез премахване на ребра (прост алгоритъм: за всеки цикъл премахваме едно участващо ребро).
Понеже $G$ е свързан, след като приключим резултантния граф $G'(V, E' \subseteq E)$ също ще е свързан $\Rightarrow$ той е дърво.

\section{Обхождане на граф в ширина и дълбочина.}

\textbf{Обхождане в ширина: } Нека $G = (V, E)$ е свързан граф. 
\begin{enumerate}
	\item Избираме начален връх $v$, $L_0 \leftarrow \{ v \}$, $l \leftarrow 0$ и наричаме $v$ обходен.
	\item Дефинираме множеството $A_l \leftarrow \{ u \in V | u \notin L_l, L_{l-1}, \dots, L_0 \text{ и } \exists w \in L_l : (w, u) \in E \}$.
	\item Ако $A_l = \varnothing$, графът е обходен и приключваме
	\item Ако $A_l \neq \varnothing$, тогава $L_{l+1} \leftarrow A_l$, $ l \leftarrow l + 1$ и повтаряме стъпка 2.
\end{enumerate}

\textbf{Построяване на покриващо дърво чрез обхождане в ширина: } Нека $G = (V, E)$ е свързан граф.
Покриващо дърво чрез BFS можем да построим, като започнем с $D_0(V_0, \varnothing)$, $V_0 = \{ v \}$ и на всяка стъпка 3 
от алгоритъма построяваме $D_l(V_l, E_l)$, където $V_l = V_{l - 1} \cup A_l$, 
$E_l = E_{l - 1} \cup \{ (w, u) \in E : w \in L_l, u \in A_l \}$. На всяка стъпка проверяваме дали 
$V = L_0 \cup L_1 \cup \dots \cup L_l$ - ако това е вярно, тогава всички върхове са обходени и $D_l(V_l, E_l)$ е покриващо дърво.
Ако BFS алгоритъмът спре по стъпка 3, но горното условие не е вярно, то $G$ не е свързан.
\vspace{10mm}

\textbf{Обхождане в дълбочина: } Нека $G = (V, E)$ е свързан граф, $r \in V$ - начален връх и обходен, 
$p(t) : V \rightarrow V$ - функция на предшествениците, $p(r)$ - неопределено, $t \rightarrow r$ - текущ връх.
\begin{enumerate}
	\item \label{dfs:checkAdj} Проверяваме за връх $u \in V$, който е необходен и е съсед на $t$.
	\begin{enumerate}
		\item Ако няма такъв връх, проверяваме дали $t = r$.
		\begin{enumerate}
			\item Ако $t = r$, то всички върхове са обходени - приключваме
			\item Ако не, $t \leftarrow p(t)$ и се връщаме на \ref{dfs:checkAdj}
		\end{enumerate}
		\item \label{dfs:addV} Ако има такъв връх, то $t \leftarrow v$, $v$ става обходен и се връщаме на \ref{dfs:checkAdj}
	\end{enumerate}
\end{enumerate} 

\textbf{Построяване на покриващо дърво чрез обхождане в дълбочина: } Нека $G = (V, E)$ е свързан граф.
Покриващо дърво на $G$ с корен $v$ можем да построим чрез алгоритъма DFS. Достъчно е да започнем
с $D_0(V_0, E_0), V_0 = \{v\}, E_0 = \varnothing$, и на всяка стъпка \ref{dfs:addV} да построим
$D_{i + 1}(V_{i + 1}, E_{i + 1}), V_{i + 1} = V_i \cup \{ v \}, E_{i + 1} = E_i \cup (t, v)$.

\section{Ойлерови обхождания на мултиграф.}
\section{Теореми за съществуване на Ойлеров цикъл (с доказателство) и Ойлеров път.}


\end{flushleft}
\end{document}
