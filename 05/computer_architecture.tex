
\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}
\usepackage{indentfirst}

\usepackage{amsmath}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}

\title{Тема 5\\ Компютърни архитектури. Формати на данните. Вътрешна структура на централен процесор – блокове и конвейерна обработка, инструкции.}
\author{v1.0}
\date{21 юни 2021}

\begin{document}

\maketitle

\tableofcontents

\section{Обща структура на компютрите и концептуално изпълнение на инструкциите,
запомнена програма.}

\subsection{Обща структура}
Компютрите се състоят от три компонента:
\begin{itemize}
    \item Централен процесор
    \item Оперативна памет
    \item Входно/изходни устройства
\end{itemize}

Централният процесор от своя страна съдържа управляво устройство (УУ) и аритметико-логическо устройство. 
Оперативната памет позволява четене и писане, като в нея се съхраняват данните, с които ЦП работи.
При фон Нойман архитектура програмата също се съхранява в ОП.

\subsubsection{Шина}
Всички тези компоненти трябва да се свържат по някакъв начин. Двата начина са връзка "всеки с всеки" и използване 
на обща шина. При втория вариант се налага използването на допълнително устройство - \textbf{арбитър на шината}, 
което управлява кои компоненти в момента ще ползват шината. Условно шината може да се раздели на три части по функция:
\begin{enumerate}
    \item за данни
    \item за адреси
    \item за контролни сигнали
\end{enumerate}

Разделението е условно, защото понякога отделните линии се припокриват. Важна характеристика е ширината на шината за адреси - тя определя
максималното количество памет, което може да се адресира от системата. Друга важна характеристика е скоростта на шината.

\subsection{Концептуално изпълнение на инструкциите}
Всяка инструкция минава през няколко етапа:
\begin{enumerate}
    \item Извличане от паметта
    \item Дешифриране
    \item Осигуряване на операнди
    \item Изпълнение
    \item Записване на резултата
\end{enumerate}

Понякога дешифрирането включва разбиване на микро-операции (среща се като \textbf{$\mu$-ops} в съответната литература).
Съвременните процесори могат да имат по няколко хардуерни блока за всеки етап и разчитат на \textbf{конвейерна} обработка
за постигане на високо бързодействие, което се получава защото по-малко време индивидуален хардуер стои "без работа".
Например, докато една инструкция е в изпълнение, следващата се извлича от паметта, а резултата от предходната се записва.
По-мощните процесори могат да имат по няколко конвейера, както и да поддържат \textbf{out of order execution}, което
размества инструкциите за по-добро запълване на конвейерите. За още повече бързодействие могат да се ползват и следните стратегии:
\begin{enumerate}
    \item \textbf{branch prediction} - отгатване по кое разклонение ще поеме програмата. Помага много, защото без него конвейрът спира 
    при първия условен преход.
    \item \textbf{speculative execution} - изпълняване на инструкции, до които не е сигурно че ще се стигне. Когато е ясно по кое разклонение
    ще продължи програмата, правилния резултат се копира.
    \item \textbf{register renaming} - "скрито" преименуване на регистри. За да е възможно това са необходими повече регистри, отколкото са видими в архитектурата.
    Намалява спиранията на конвейера.
\end{enumerate} 

\subsection{Запомнена програма}
Програмите, които се изпълняват, са записани на някаква трайна памет - например \textbf{ROM} или твърд диск.
При фон Нойман архитектурата те трябва да се заредят в ОП преди да се изпълнят. При Харвард архитектурата 
се четат директно от паметта, предназначена само за тях.

Всяка програма има поне една нишка. Нишките са подпрограми, които се изпълняват конкурентно. Всяка нишка може да 
бъде прекъсната по всяко време - например от грешка, от ОС с времеделене или от външно прекъсване.
Архитектурата на процесори, поддържащи нишки, съдържат и механизми, които в комбинация с ОС, правят прекъсванията
"прозрачни" - изпълнението на програмата не разбира, че е било прекъснато. За целта преди обработка на прекъсването се съхраняват
текущите регистри, които включват стековия указател, указателя на следващата инструкция, указателите към сегментите с данни и др.
След като приключи обработката на прекъсването, всички те се възстановят и изпълнението продължава от адреса, където е прекъснато.

\section{Формати на данните}

\subsection{Цели двоични числа}
\label{subsection:integers}
Целите числа се представят в двоична бройна система в групи от 8, 16, 32 или 64 бита. Съответно групата от 8 бита се нарича \textbf{байт},
а една от останалите - \textbf{машинна дума}, в зависимост от разрядността на процесора. Целите числа могат да бъдат със и без знак.
Отрицателните числа със знак се представят по схемата \textbf{допълнение към двойката} - най-старшият бит се ползва за знак (0 - положително число, 1 - отрицателно).
Нека е дадено двоично числа със знак с $N$ бита. Неговата стойност е
\[ \overline{a_{N-1} a_{N-2} \dots a_0}_{2c} = \begin{cases}
    \overline{a_{N-2} a_{N-3} \dots a_0}_2, & a_{N-1} = 0 \\
    -2^{N-1} + \overline{a_{N-2} a_{N-3} \dots a_0}_2, & a_{N-1} = 1
\end{cases}
\]

Минималните и максималните стойности за $N$-битово число с това представяне са съответно $-2^{N-1}$ и $2^{N-1} - 1$ - не са симетрични. 
Нулата има единствено представяне - $\overline{00\dots0}_{2c}$, което съвпада с нейното представяне за неотрицателни числа.
Част от причините тази схема да се ползва, е че няма нужда от различен хардуер за събиране и изваждане - възползваме се от превъртането (overflow).

\textit{Пример: } $-1 + 3 = \overline{1111}_{2c} + \overline{0011}_{2c} = \overline{0010}_{2c} = 2$. 

Хардуера за умножение и деление обаче не може да игнорира старшия бит за знак - и това се отразява във съотвените инструкции.

\subsection{Двоично-десетични числа}
Архитектурата \textbf{x86} поддържа \textbf{двоични-десетични числа (binary coded decimal)}, които използват десетична бройна система като
записват всяка десетична цифра с 4 бита. Съществуват два формата:
\begin{itemize}
    \item \textbf{пакетиран}, при който се съхраняват две десетични цифри в байт, и
    \item \textbf{непакетиран}, при който се съхранява по една десетична цифра в байт
\end{itemize}
Както се вижда, този формат е по-неефикасен откъм място за съхранение. По неефикасен е и за пресмятане, понеже всички операции са 
дефинирани над напрактика низове, вместо машинни думи. Предимство на формата е че няма загуби при конверсия на десетични рационални числа
(например $0.3$ е безкрайна двоична дроб).

\subsection{Двоично числа с плаваща запетая}
Рационалните числа се представят чрез \textbf{двоични числа с плаваща запетая (floating point)}.
Ирационални числа (напр. $\sqrt{2}, \pi$) не могат да се представят с крайна памет, така че се апроксимират с рационални.
Те са разделени на три части: знак (1 бит), мантиса и експонента. Стойността на такова число е \textbf{sgn} $ \times $ $ m \times 2^e$.
Процесорите най-често имплементират стандарт \textbf{IEEE 754}, и по-точно два формата от него:
\begin{itemize}
    \item \textbf{binary32}, наричан още \textbf{single precision}. Ползва 24 бита за мантиса и 8 за експонента. В езиците за програмиране най-често се нарича \textbf{float}.
    \item \textbf{binary64}, наричан още \textbf{double precision}. Ползва 53 бита за мантиса и 11 за експонента. В езиците за програмиране най-често се нарича \textbf{double}.
\end{itemize}

\textbf{TODO}: Повече обяснения как работи

\subsection{Символни данни и кодови таблици}
Символните низове се представят чрез поредица от числа - най-често 8 битови, но понякога 16 или 32-битови. 
За интерпретация (и печатане) на символите се използват \textbf{кодови таблици}, като най-често срещаните са:
\begin{itemize}
    \item \textbf{ASCII} - използва фиксирана големина на символ 1 байт. Стойностите от 0 до 127 са винаги едни и същи, докато
    $[128,255]$ са различни в зависимост от настройката за регион на компютъра. Тази различност е най-честата причина за нечетими
    текстови файлове и съобщения - някои стари програми и/или ОС използват регионалната ASCII таблица.
    \item \textbf{UTF-8} - използва кодиране с променлива дължина на символите. Съвпада с ASCII до 127 включително.
    \item \textbf{UTF-16} и \textbf{UTF-32} - използва същите кодове като \textbf{UTF-8}, но използва фиксирана дължина 2 или 4 байта
\end{itemize}

Исторически са ползвани и други таблици - например \textbf{EBCDIC}, но са изпаднали от употреба. Най-простият вариант за рисуването на 
символите е да има таблица от правоъгълни матрици с еднакъв размер, като една матрица отговаря на един символ. Всеки символ се ползва
като индекс в таблицата и отговарящата матрица се копира на съответното място на екрана.

\section{Вътрешна структура на централен процесор}
\subsection{Регистри}
Регистрите представляват изключително бърза памет (всъщност най-бързата в системата) с много малък размер. Обикновено големината им е от 8 до 512 бита (напр. при AVX512),
като повечето са с големината на машинната дума (16, 32, 64) или някое нейно кратно число. Можем да ги разделим на няколко вида:
\begin{itemize}
    \item С общо предназначение
    \item За числа с плаваща запетая
    \item SIMD регистри
    \item Сегментни регистри
    \item Флагови и контролни регистри
    \item Указател на следващата инструкция
\end{itemize}

Общият брой регистри е от порядъка на 128. Ще разгледаме някои регистри на \textbf{x86} архитектурата по-подробно.

\subsubsection{Регистри с общо предназначение}
Това са регистрите \textit{AX, BX, CX, DX, BP, SI, DI, SP} - 16 битови. При 32-битовия вариант се добавя представка \textit{E-} (напр. \textit{EAX}),
а за 64-битов вариант се добавя \textit{R-} (напр. \textit{RAX}). Разбира се, 32 и 64-битовите варианти се поддържат единствено на 32 и 64 битова архитектура.

По-големите регистри съдържат по-малките - например за \textit{A} регистъра \textit{AX} образува долните 16 бита на \textit{EAX} и \textit{RAX},
a \textit{EAX} съдържа долните 32 бита на \textit{RAX}. 
Регистрите \textit{A,B,C,D} се делят на още две части - \textit{H} и \textit{L} (напр. \textit{AH, AL}), които са 8 битови. 
При \textbf{x86\_64} са добавени още 8 регистъра - \textit{R8..R15}, като долните 32 бита са достъпни като \textit{R8D..R15D}.

Ще опишем накратко употребата на тези регистри:
\begin{itemize}
    \item \textit{AX} - акумулатор, предназначен за операнди и резултати.
    \item \textit{BX} - \textbf{base} регистър за адреси в паметта.
    \item \textit{CX} - \textbf{counter} (брояч). Използва се за цикли.
    \item \textit{DX} - за данни. Ползва се за входно-изходни устройства и някои аритметични операции.
    \item \textit{SP} - стеков регистър. Сочи към първата свободна памет на стека.
    \item \textit{BP} - базов стеков регистър. Запазва състоянието (размера на стека) при влизане във функция.
    \item \textit{SI} - \textbf{source index}. Използва се за указател към входни данни, понякога заедно със сегментния \textit{DS}.
    \item \textit{DI} - \textbf{destination index}. Използва се за указател към изходните данни, понякога заедно със сегментния \textit{ES}.
\end{itemize}

Предназначението често е условно - повечето регистри могат да се ползват за повечето операции.

\subsubsection{Регистри за числа с плаваща запетая}
Това са \textit{ST0 ... ST7}, които са организирани като стек. Всеки е с големина 80 бита (стандарта за числа с плаваща запетая позволява
междинните резултати да са с по-голяма прецизност).

\subsubsection{SIMD регистри}
Това са регистри, които се появяват по-късно в еволюцията на \textbf{x86} архитектурата. Съкращението \textbf{SIMD} означава \textbf{single instruction, multiple data}, т.е. са предназначени да съдържат няколко типа с по-малък размер. Първоначално се добавят MMX регистрите, които всъщност се припкриват със 
\textit{ST0 ... ST7} и са със ширина 64 бита. След това се добавят XMM, YMM и ZMM регистри със ширина 128, 256 и 512 бита.

\subsubsection{Сегментни регистри}
Те са 6 на брой и всеки от тях е 16 битов, независимо от това колко битов е процесора (не стават по-големи, за разлика от гореописаните).
Използват се при включена сегментация на паметта. Всеки регистър съдържа селектор за сегмент, който е или указател към началото, или индекс
в таблица със сегменти.
\begin{itemize}
    \item \textit{CS} - \textbf{code segment}. Съдържа селектора за сегмента на програмата (изпълнимия код).
    \item \textit{DS} - \textbf{data segment}. Селектор за данните.
    \item \textit{ES} - \textbf{extra segment}. Допълнителен селектор за данни - често се използва за записване на резултат.
    \item \textit{SS} - \textbf{stack segment}. Съдържа селектора за стека.
    \item \textit{FS, GS} - допълнителни селектори без зададено предназначение.
\end{itemize}

При адресиране в паметта сегментният регистър може да се укаже изрично, но при много инструкции има "стандарни" регистри, които се ползват.
При 64-битов режим на работа всички сегменти регистри, освен \textit{FS} и \textit{GS}, се нулират.

\subsubsection{Указател на следващата инструкция}
Това е регистърът \textit{IP/EIP/RIP} - \textbf{instruction pointer}. Популярно наименование на регистър с тази функция е също 
\textit{PC} - \textbf{Program Counter}. Функцията му е просто: съдържа адреса на следващата инструкция, която трябва да се изпълни.
При \textbf{x86} архитектурата този регистър не може да се пише или чете директно - това се случва чрез инструкции за преходи.

Регистърът за флагове, както и контролните регистри, разглеждаме в \ref{section:flags}.

\subsection{Аритметико-логическо устройство}
Специализиран блок, който извършва аритметичните (+, -, умножение, деление) и логически (and, or, \dots) операции. Основна част е пълния двоичен събирач (\textbf{full adder}).

\subsection{Регистър на състоянието и флагове}
\label{section:flags}
Флаговият регистър се казва \textit{FLAGS}. "Флагове" наричаме индивидуални негови битове, като биват три вида: статус, контролни и системни.
Статусните се попълват автоматично като резултати на аритметико-логически операции и са само за четене:
\begin{itemize}
    \item \textbf{Zero}
    \item \textbf{Overflow}
    \item \textbf{Carry}
    \item \textbf{Auxillary carry}
\end{itemize}

Контролните флагове могат да бъдат записвани от програмата, за да (изненада) контролират поведението на процесора.
\begin{itemize}
    \item \textbf{Interrupt enable flag} - включва и изключва обработването на външните прекъсвания.
    \item \textbf{Direction flag} - указва дали низовете да се обработват от ниски към високи адреси или обратно.
\end{itemize}

От системните флагове може да се извлече информация за текущата конфигурация на процесора.

Контролните регистри са \textit{CR0,\dots,CR7}, като директно използваеми са \textit{CR0, CR2, CR3} и \textit{CR4}. Използват се за:
\begin{itemize}
    \item Задаване на режим на процесора (реален, привилегирован, виртуално 8086)
    \item Странициране - включване + адреси на таблици + адрес, който е генерирал \textbf{page fault}
    \item Прекъсвания
    \item Получаване на информация за конфигурацията
    \item и други
\end{itemize}

Освен тях съществуват и други регистри, които съдържат адреси на разнообразни таблици.

\subsection{Блок за управление}
Това е частта, която координира всичко - чрез електрически импулси от генератор (\textbf{clock}).
Отговаря за извличане на инструкции от паметта, тяхното декодиране, извличане на операнди, подаването им
на правилния хардуер в АЛУ и записване на резултата. При по-сложните архитектури (почти всички съвременни)
следи коя инструкция в кой етап на изпълнение е и на кое изпълнително устройство да се даде.

\section{Инструкции на централен процесор}
Инструкциите на \textbf{x86} имат следните полета (изброени в реда на появяване):
\begin{enumerate}
    \item Префикси
    \item REX префикс
    \item Код на операцията
    \item ModR/M байт
    \item SIB байт
    \item Отместване
    \item \textbf{Immediate} операнд
\end{enumerate}

\subsection{Префикси}
Това са незадължителни полета. Първите префикси се делят на четири групи:
\begin{enumerate}
    \item \label{prefix:group1} \textbf{LOCK}, която служи за ексклузивно ползване на споделена памет, и префикси за повторение, които се ползват за низови и \textbf{I/O} инструкции
    \item Подсказки за разклонения
    \item Промяна на размера на операнда
    \item Промяна на размера на адресите 
\end{enumerate}

REX префикса се използва в 64 битов режим на работа. Необходим е за използване на допълнителните регистри, или за указване на 64-битови данни/адреси.

\subsection{Код на операцията}
Поредица от байтове, които указват какво трябва да свърши процесора. При \textbf{x86} това поле може да е с променлива дължина (1-3 байта), докато 
при други архитектури може да е фиксирано.

\subsection{Местоположение на операндите}
Операндите на всяка инструкция могат да са \textbf{immediate} (записани директно в инструкцията, т.е. константи), да се намират в регистри 
или в паметта. При някои инструкции някои операнди са зададени директно в кода на операцията.

\subsection{Модели на адресация на операндите}
Има няколко начина инструкция да си намери операндите:
\begin{enumerate}
    \item регистърна адресация - в инструкцията е зададен код на регистър, чиято стойност трябва да се ползва/запише
    \item директна - адреса в паметта е подаден като отместване
    \item индиректна - адреса в паметта се получава от няколко регистъра, чиито кодове са записани в инструкцията
\end{enumerate}

Всички архитектури поддържат двойките на адресация "регистър-памет" за зареждане и записване и "регистър-регистър" за АЛ операции. 
\textbf{CISC} архитектурите, каквато е \textbf{x86}, поддържат и аритметико-логически операции "регистър-памет".

При \textbf{x86} индиректната адресация винаги работи по формулата $ base + index . 2^{scale} + displacement $,
където \textbf{scale}, \textbf{index} и \textbf{base} са регистри, които се задават с комбинация от 
\textbf{ModR/M}, \textbf{SIB} (чието съкращение идва от точно тези 3 думи) и \textbf{REX}. Всяка част от формулата
може да бъде пропусната - напр. не е необходимо два регистъра да се задават на 0, ако ползваме директно адреса от 1 регистър.

\subsection{Аритметико-логически инструкции}
\subsubsection{С цели числа}
Това са инструкциите за увеличаване/намаляване с 1 (\textbf{INC / DEC}), събиране и изваждане (\textbf{ADD / SUB}),
умножение и деление на числа без знак (\textbf{MUL / DIV}), както и на числа със знак (\textbf{IMUL / IDIV}).
Причината само умножението и делението да са "разделени" обсъдихме в \ref{subsection:integers}.
Всички тези операции имат страничен ефект - променят флагове във флаговия регистър.

Към тази група операции причисляваме и побитовите операции - \textbf{AND, OR, XOR, NOT}, които също променят флаговете.
Има и допълнителен вариант на \textbf{AND} - \textbf{TEST}, който единствено променя флаговете, но не и операндите.

Като финална инструкция от групата можем да смятаме \textbf{CMP}, която, както й подсказва името, извършва сравнения.
Резултата от тях отново се отразява във флаговия регистър.

\subsubsection{С числа с плаваща запетая}
Числата с плаваща запетая имат аналог на всички гореописани инструкции, плюс допълнителни:
\begin{enumerate}
    \item конверсия към и от цели числа
    \item модул (абсолютна стойност)
    \item аритметични операции между числа с плаваща запетая и цели числа
    \item тригонометрични операции
\end{enumerate}

\subsection{Низови инструкции}
При \textbf{x86} са добавени допълнителни инструкции с цел ускоряване на работата със символни низове.
Тези инструкции могат да се ползват вместо конвенционални цикли, които заемат няколко други инструкции.
Общо има 5 низови инструкции, като размера на символа може да е 8, 16 или 32 битов.
\begin{enumerate}
    \item \textbf{MOVS} - копира символ от един низ в друг
    \item \textbf{LODS} - зарежда символ от низ в съответната част от \textbf{A} регистъра.
    \item \textbf{STOS} - записва символа от съответната част от \textbf{A} регистъра в низ.
    \item \textbf{CMPS} - сравнява два символа от два низа.
    \item \textbf{SCAS} - сравнява символ от низ със съдържанието на съответната част от \textbf{X} регистъра.
\end{enumerate}

Тези инструкции могат да се комбинират с префикси за повторение - група \ref{prefix:group1}. 
В зависимост от представката, инструкцията се повтаря докато \textbf{ECX} стане 0 или се стигне
до равенство/неравенство.

\subsection{Безусловни и условни преходи}
Инструкциите за преход променят откъде се взима следващата инструкция, т.е. \textit{IP} регистъра.
Някои преходи са безусловни - винаги се изпълняват. В \textbf{x86} това е инструкцията \textbf{JMP}.
Други се изпълняват, ако е изпълнено някакво условие. Условието обикновено се взима от флаговия регистър.

Специален тип инструкции за преход са извикването (\textbf{CALL}) и връщането (\textbf{RET}) от функции.
При извикване на стека се записват аргументите на функцията, както и регистъра на следващата инструкция (\textit{IP}).
При връщане от функцията се прави скок на записания в стека адрес.

\subsection{Управление на програмата}
Това са инструкции, които могат да се изпълнят единствено в привилегирован режим на процесора.
Това са всички инструкции, пишещи служебни регистри, изпълняващи входно/изходна дейност и 
обслужващи прекъсвания.


\end{document}
