
\documentclass[fleqn,12pt]{article}

\usepackage[margin=15mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage[unicode]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem, hyperref}
\usepackage{upgreek}
\usepackage{indentfirst}
\usepackage{array}
\usepackage{listings}

\usepackage{amsmath}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\LCS}{LCS}
\DeclareMathOperator{\longer}{longer}

\title{Тема 12\\Обектно ориентирано програмиране (на базата на C++ или Java): Основни
принципи. Класове и обекти. Конструктори и деструктори. Оператори.
Производни класове и наследяване.}

\author{v0.1}
\date{28 юни 2021}

\begin{document}

\maketitle

\tableofcontents

\section{Основни принципи}
\subsection{Капсулация}
Обектите крият своето вътрешно състояние - само те могат да го модифицират директно. 
Клиентският код има достъп до него само през специфични методи на самия обект.

\subsection{Абстракция}
Обектите показват на външния свят само своя интерфейс, но не и допълнителни детайли. 
За всеки обект се знае какво прави, но не и как го прави.

\subsection{Наследяване}
Клас може да наследява друг клас. При това той включва в себе си всички полета и методи на класа, който е наследил.
Дали дадено поле от базовия клас ще е видимо в наследнения зависи от неговия спецификатор на достъп:
\begin{itemize}
    \item \textbf{public} - вижда се навсякъде
    \item \textbf{private} - вижда се само в базовия клас
    \item \textbf{protected} - вижда се в базовия и всички наследници
\end{itemize}

\subsection{Полиморфизъм}
Буквален превод - \textit{много форми}. В случая означава, че може да съществуват методи с едни и същи имена, но различен интерфейс (различен тип и/или брой входни данни; методи не могат да се различават само по типа, който връщат).

\section{Класове}
\subsection{Дефиниция}
Класовете в обектно ориентираните езици представляват шаблон, по който се генерират обекти. В тях са имплементирани методи, които определят какво е поведението му по време на живота му в програмата. 


\subsection{Дефиниране на класове}
\begin{lstlisting}[language=C++, caption=Example sckeletal definition of a class]
    class X
    {
        private:
            int a; //a memmber of the class
            void aPrivateMethod();
            voif inlineMethod() {//logic of the inline method}

        protected:
            void aProtectedMethod(); //visible for X and any derived class of X

        public:
        X() 
        {
            //example constructor
        }

        void aPublicMethod();
    
        // Other logic of the class...
    };

    void X::aPrivateMethod()
    {
        //Logic of the private method
    }

    void X::aPublicMethod()
    {
        //Logic of the public method
    }
    
\end{lstlisting}


\subsection{Област на класове}
TODO

\subsection{Обекти}
Обектите са инстанции (екземпляри) на класове.

Очаквания за един обект на даден клас е, че той трябва да си гарантира, че във всеки момент е в правилно състояние и когато достигне края на живота си да не остават следи от него - да почиства запазената си памет


\section{Конструктори}
\subsection{Дефиниция}
Конструкторите са специални методи, които се извикват единствено при създаване на обект.

\subsection{Дефиниране на конструктори}
Дефиниите на конструктори са от вида \textbf{<class name>(<parameter list>) : <field>(value), <field>(value), \dots}.
Съответно може да има само дефиниця, при която веднага следва блок с кода на конструктора,
или декларация + дефиниция. Ако програмиста избере да използва синтаксиса \textbf{<field>(value)}, дефиницията на тези полета е с по-висок приоритет и се изпълнява преди изпълняването на кода в тялото на конструктора 

\subsection{Видове конструктори}
\subsubsection{По подразбиране}
Важен вид конструктор е констуктора по подразбиране. Той се генерира автоматично от компилатора, 
когато не са дефинирани конструктори. Не приема аргументи и единствено инициализира всички полета със стойностите им по подразбиране или със специфично избрани стойности, ако конструктора по подразбиране е предифиниран.
Извиква се, когато обект се създава без скобки, например:
\begin{lstlisting}[language=C++, caption=Default constructor]
class X
{
    X()
    {
        //Logic of the constructor
    }

    // Other logic of the class...
};

X x; // default constructor called
\end{lstlisting}

\subsection{Параметризиран конструктор}
Това е конструктор, който приема параметри. Пише се ръчно от програмиста, който решава и какво точно да прави с тях
в тялото на конструктора. Може да има произволен брой параметризирани конструктори. При наличието на разписан конструктор в деффиницията на класа, конструктора по подразбиране бива предифиниран и повече не може да се използва. Ако все пак искаме да може да генерираме обекти използвайки конструктора по подразбиране, трябва специфично да разпишем и конструктора по подразбиране, дори и тялото му да е празно.

\subsection{Копиращ конструктор (copy constructor)}
Това е специален параметризиран конструктор, който като единствен параметър получава псевдоним (\textbf{X\&}) на обект от същия клас.
Работата му е да клонира подадения обект. Компилатор създава копиращ конструктор по подразбиране. При наличието на динамично заделяне на памет за член данни на клас този конструктор трябва да бъде предефиниран ръчно от програмиста.

\begin{lstlisting}[language=C++, caption=Copy constructor]
    class X
    {
        X(const X& x)
        {
            //Logic of the constructor
        }
    
        // Other logic of the class...
    };
    
    X x; // default constructor called
    \end{lstlisting}
    

% This was written by Kosyo and sounds too modern to be a part of this exam
\subsection{Преместващ конструктор (move constructor)}
Този приема единствен параметър от тип \textbf{T\&\&} и работата му е да \textit{премести} съдържанието на подадения обект 
в новосъздаващият се. Обектът-параметър остава \textit{празен} и най-вероятно не трябва да се използва.
Компилатора създава такъв конструктор по подразбиране.

\section{Указатели към обекти. Масиви и обекти. Динамични обекти}

% This whole section is bullshit and there is litterally nothing to say
\subsection{Указатели към обекти}
Подобно на атомарните обекти можем да правим указатели към обекти. 
\begin{lstlisting}[language=C++, caption=Example creation of pointers]
    class X {\\Relevant logic}

    X x;
    X * prt = &x
    prt -> class_method_name // this is how you call a method of the class through the pointer
\end{lstlisting}


\subsection{Масиви от обекти}
Обектите могат да се групират в масиви като нормални атомарни типове. Единственото условие е класът да има конструктор по подразбиране. Този конструктор ще се извика, когато масива бъде дефиниран.

\begin{lstlisting}[language=C++, caption=Example creation of an array of objects]
    class X {\\Relevant logic}

    X array[10] // In this moment the default constructor is called for the 10 elements created.
\end{lstlisting}


\subsection{Динамични обекти}
Отново обектите се държат като нормални атомарни типове. Може да заделяма памет за тях използвайки оператора \textit{new} и в последствие освобождаването на тази памет с \textit{delete}


\section{Деструктори}
\subsection{Дефиниция}
Деструкторите са специални методи, които се извикват при унищожаване на обекти. При създаването си памет е заделена за всички член данни на обекта и при извикването на деструктора тази памет бива освободена. Съществува само един деструктор за всеки клас. Ако няма специфично дефиниран в кода на класа деструктор се използва деструктор по подразбиране. 

\begin{lstlisting}[language=C++, caption=Example destructor]
    class X
    {
        //Other logic of the class ...

        //Destructor
        ~X()
        {
            //Code of the destructor
            //Empty by default
        }
    };
    
\end{lstlisting}
    

\subsection{Създаване и разрушаване на обекти на класове}
Всеки обект започва жизнения си цикъл обръщайки се към един от конструкторите на класа или чрез присвояване на обект. По време на създаването си или в процеса на жизнения си цикъл, за член данни на обекта може да бъде заделена динамична памет. 

Диструкторът не се вика експлицитно, той се изпълнява, когато се достигне края на scope или при изпълняване на оператора delete с динамично генериран обект. 

Деструктора по подразбиране може да се справи с освобождаването на паметта заета от статични данни, дори и на обекти от други класове, извиквайки техните деструктори. Класовете, които са наследници на друг клас, също могат сами да се погрижат за почистването на данните си, извиквайки деструктора на базовия клас, след като изпълнят инструкциите зададени в своя деструктор.

При наличието на заделена динамична памет, трябва да има специфично зададен деструктор. В противен случай заделената памет няма да бъде освободена

\begin{lstlisting}[language=C++, caption=Example custom destructor]
    class X
    {
        int * someArray;

        X() 
        {
            someArray = new int[10]; // example of dynamically generated memory
        }

        //Other logic of the class ...

        //Destructor
        ~X()
        {
            //Code of the destructor
            delete someArray;
        }
    };
    
\end{lstlisting}


\section{Оператори}
\subsection{Дефиниция}
Операторите са конструкции в програмните езици, които напрактика се държат като функции, но имат различен синтаксис. 

\begin{lstlisting}[language=C++, caption=Example use of operators]
    int a, b;
    int c = a + b;
\end{lstlisting}

\begin{lstlisting}[language=C++, caption=Equivalent use of operators]
    int a, b;
    int c = a.operator+(b);
\end{lstlisting}

Двете дефиниции по горе са еквиваленти, но първата е лесна за четене от човек.


\subsection{Предефиниране на оператори}
Операторите могат да се спрвят добре, когато са приложени върху атомарните типове предоставени от програмния език, но не могат да се използват в комбинация с класове. В такива случаи кода на класовете трябва да предифинират операторите, които ще бъдат използвани в комбинация с този тип обекти. Нищо не спира предефинираните оператори да се държат по произволен начин, но е предпочитано да се държат като стандартните, за да има някакъв смисъл.

\begin{lstlisting}[language=C++, caption=Example overriding of an operator]
    class X
    {
        //Other logic of the class ...

        X::operator+(cosnt X& x) const {
            //Relevant logic
        }
    };
    
\end{lstlisting}


\section{Производни класове}
\subsection{Дефиниция}
Наследяване е механизъм, чрез който производния клас бива базиран върху логиката на друг базов/прототипен клас. Производния клас наследява, разширява и предефинира интерфейса на базовия клас. 

\begin{lstlisting}[language=C++, caption=Example inheritence]
    class X
    {
        public:
        void publicMethod();
        // Logic of the base class
    };

    class Y : (public|protected|private) X
    {
        // Logic of the derived class
    };

    Y y;

    y.publicMethod; // Derived class using method of base class
    
\end{lstlisting}

Някой програмни езици (ex. C++) позволяват множествено наследяване, където един клас А, може да има два родителски класа B и C. Това се дефинира като \textbf{ class A : public B, public C}. В този случай при създаването на нов обект от класа A първо се извиква конструктора на базовия клас B, полсе конструктора на базовия клас C и накрая се изпълнява конструктора на А

Приятелски методе и класове на производния клас не виждат private елементите на базовия клас.

\subsection{Наследяване и достъп до наследените компоненти}
При наследяване производния клас има достъп до public и protecetd методите и полетата на базовия клас. Всички данни на базовия клас, които са private, остават скрити от производния клас. 

В C++ в зависимост от типа на наследяването тези наследени методи и данни се третират по различен начин. Public наследяването е най-често използвания вид наследяване. При него public методите и променливи на базовия клас стават част от публичната част на интерфейса на производния глас, а protected нещата стават protected методи и променливи на производния клас.

При protected наследяването public интерефейса и protected методите и полета стават на базовия клас стават protected елементи на производния клас. В този случай производния клас не се вижда като подвид на базовия клас (не е възможно да има преобразуване от производния към базовия клас). Методите на базовия клас могат да се използват само от вътре в производния клас.

Ако не се отбележи какво е наследяването стандартно е private. В този случай и public и private елементите на базовия клас се превръщат в privat елементи на производния клас. Като се изключи факта, че производния клас има достъп до protected елементите, няма разлика между private наследяване и влагане (превръщане на базовия клас в private член данна на производния клас)


\end{document}
 